<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>エディションガイド</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/em-to-bold.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">序文</a></li><li class="chapter-item expanded "><a href="editions/index.html"><strong aria-hidden="true">1.</strong> エディションとは？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="editions/creating-a-new-project.html"><strong aria-hidden="true">1.1.</strong> 新しいプロジェクトを作成する</a></li><li class="chapter-item expanded "><a href="editions/transitioning-an-existing-project-to-a-new-edition.html"><strong aria-hidden="true">1.2.</strong> 既存のプロジェクトのエディションを移行する</a></li><li class="chapter-item expanded "><a href="editions/advanced-migrations.html"><strong aria-hidden="true">1.3.</strong> 発展的な移行戦略</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li class="chapter-item expanded "><a href="rust-2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/path-changes.html"><strong aria-hidden="true">3.1.</strong> Path and module system changes</a></li><li class="chapter-item expanded "><a href="rust-2018/trait-fn-parameters.html"><strong aria-hidden="true">3.2.</strong> トレイト関数の匿名パラメータの非推奨化</a></li><li class="chapter-item expanded "><a href="rust-2018/new-keywords.html"><strong aria-hidden="true">3.3.</strong> New keywords</a></li><li class="chapter-item expanded "><a href="rust-2018/tyvar-behind-raw-pointer.html"><strong aria-hidden="true">3.4.</strong> Method dispatch for raw pointers to inference variables</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo.html"><strong aria-hidden="true">3.5.</strong> Cargo changes</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2021/index.html"><strong aria-hidden="true">4.</strong> Rust 2021</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2021/prelude.html"><strong aria-hidden="true">4.1.</strong> Prelude への追加</a></li><li class="chapter-item expanded "><a href="rust-2021/default-cargo-resolver.html"><strong aria-hidden="true">4.2.</strong> デフォルトの Cargo のフィーチャリゾルバ</a></li><li class="chapter-item expanded "><a href="rust-2021/IntoIterator-for-arrays.html"><strong aria-hidden="true">4.3.</strong> 配列に対する IntoIterator</a></li><li class="chapter-item expanded "><a href="rust-2021/disjoint-capture-in-closures.html"><strong aria-hidden="true">4.4.</strong> クロージャはフィールドごとにキャプチャする</a></li><li class="chapter-item expanded "><a href="rust-2021/panic-macro-consistency.html"><strong aria-hidden="true">4.5.</strong> panic マクロの一貫性</a></li><li class="chapter-item expanded "><a href="rust-2021/reserving-syntax.html"><strong aria-hidden="true">4.6.</strong> 構文の予約</a></li><li class="chapter-item expanded "><a href="rust-2021/warnings-promoted-to-error.html"><strong aria-hidden="true">4.7.</strong> 警告からエラーへの格上げ</a></li><li class="chapter-item expanded "><a href="rust-2021/or-patterns-macro-rules.html"><strong aria-hidden="true">4.8.</strong> マクロ規則における OR パターン</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">エディションガイド</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-ja/edition-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Introduction
-->
<h1 id="序文"><a class="header" href="#序文">序文</a></h1>
<!--
Welcome to the Rust Edition Guide! "Editions" are Rust's way of introducing
changes into the language that would not otherwise be backwards
compatible.
-->
<p>Rust エディションガイドへようこそ！
「エディション」とは、Rust に後方互換性が保てなくなるようなアップデートを行うための方法です。</p>
<!--
In this guide, we'll discuss:
-->
<p>このガイドでは、下記の項目について説明します：</p>
<!--
* What editions are
* Which changes are contained in each edition
* How to migrate your code from one edition to another
-->
<ul>
<li>エディションとは何か</li>
<li>各エディションの変更内容</li>
<li>コードをあるエディションから別のエディションへ移行する方法</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# What are Editions?
-->
<h1 id="エディションとは"><a class="header" href="#エディションとは">エディションとは？</a></h1>
<!--
The release of Rust 1.0 established
["stability without stagnation"](https://blog.rust-lang.org/2014/10/30/Stability.html)
as a core Rust deliverable.
Ever since the 1.0 release,
the rule for Rust has been that once a feature has been released on stable,
we are committed to supporting that feature for all future releases.
-->
<p>Rust 1.0 のリリースでは、Rust のコア機能として<a href="https://blog.rust-lang.org/2014/10/30/Stability.html">「よどみない安定性」</a>が提供されるようになりました。
Rust は、1.0 のリリース以来、いちど安定版にリリースされた機能は、将来の全リリースに渡ってサポートし続ける、というルールの下で開発されてきました。</p>
<!--
There are times, however, when it is useful to be able to make small changes
to the language that are not backwards compatible.
The most obvious example is introducing a new keyword,
which would invalidate variables with the same name.
For example, the first version of Rust did not have the `async` and `await` keywords.
Suddenly changing those words to keywords in a later version would've broken code like `let async = 1;`.
-->
<p>一方で、後方互換でないような小さい変更を言語に加えることも、ときには便利です。
最もわかりやすいのは新しいキーワードの導入で、これは同名の変数を使えなくします。
例えば、Rust の最初のバージョンには <code>async</code> や <code>await</code> といったキーワードはありませんでした。
後のバージョンになってこれらを突然キーワードに変えてしまうと、例えば <code>let async = 1;</code> のようなコードが壊れてしまいます。</p>
<!--
**Editions** are the mechanism we use to solve this problem.
When we want to release a feature that would otherwise be backwards incompatible,
we do so as part of a new Rust *edition*.
Editions are opt-in, and so existing crates do
not see these changes until they explicitly migrate over to the new edition.
This means that even the latest version of Rust will still *not* treat `async` as a keyword,
unless edition 2018 or later is chosen.
This choice is made *per crate* [as part of its `Cargo.toml`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field).
New crates created by `cargo new` are always configured to use the latest stable edition.
-->
<p>このような問題を解決するために、<strong>エディション</strong>という仕組みが使われています。
後方互換性を失わせるような機能をリリースしたいとき、我々はこれを新しい<em>エディション</em>の一部として提供します。
エディションはオプトイン、すなわち導入したい人だけが導入できるので、既存のクレートは明示的に新しいエディションに移行しない限りは変化を受けません。
すなわち、2018 以降のエディションを選択しない限り、たとえ最新バージョンの Rust であっても <code>async</code> はキーワードとして<em>扱われません</em>。
導入の可否は<em>クレートごとに</em>決めることができ、<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field"><code>Cargo.toml</code> への記載内容</a>により決定されます。
<code>cargo new</code> コマンドで作成される新しいクレートは、常に最新の安定版のエディションでセットアップされます。</p>
<!--
### Editions do not split the ecosystem
-->
<h3 id="エディションはエコシステムを分断しない"><a class="header" href="#エディションはエコシステムを分断しない">エディションはエコシステムを分断しない</a></h3>
<!--
The most important rule for editions is that crates in one edition can
interoperate seamlessly with crates compiled in other editions. This ensures
that the decision to migrate to a newer edition is a "private one" that the
crate can make without affecting others.
-->
<p>エディションで最も重要な規則は、あるエディションのクレートと別のエディションでコンパイルされたクレートがシームレスに相互運用できるようになっているということです。
これにより、新しいエディションへ移行するかどうかは、他のクレートに影響を与えない「自分だけの問題」だと言えるのです。</p>
<!--
The requirement for crate interoperability implies some limits on the kinds of
changes that we can make in an edition.
In general, changes that occur in an edition tend to be "skin deep".
All Rust code, regardless of edition,
is ultimately compiled to the same internal representation within the compiler.
-->
<p>クレートの相互運用性を守るために、我々がエディションに加えられる変更にはある種の制限がかかります。
一般に、エディションに加えられる変更は「表面上の」ものになりがちです。
エディションに関わらず、すべての Rust のコードは最終的にはコンパイラの中で同じ内部表現に変換されるのです。</p>
<!--
### Edition migration is easy and largely automated
-->
<h3 id="エディションの移行は簡単でほとんど自動化されている"><a class="header" href="#エディションの移行は簡単でほとんど自動化されている">エディションの移行は簡単で、ほとんど自動化されている</a></h3>
<!--
Our goal is to make it easy for crates to upgrade to a new edition.
When we release a new edition,
we also provide [tooling to automate the migration](https://doc.rust-lang.org/cargo/commands/cargo-fix.html).
It makes minor changes to your code necessary to make it compatible with the new edition.
For example, when migrating to Rust 2018, it changes anything named `async` to use the equivalent
[raw identifier syntax](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html): `r#async`.
-->
<p>我々は、クレートを新しいエディションにアップグレードするのが簡単になるよう目指しています。
新しいエディションがリリースされるとき、我々は<a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html">移行を自動化するツール</a>も提供します。
このツールは、新しいエディションに適合させるために必要な小さな変更をコードに施します。
例えば、Rust 2018 への移行の際は、<code>async</code> と名のつく全てのものを、等価な<a href="https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html">生識別子構文</a>である <code>r#async</code> へと書き換える、といった具合です。</p>
<!--
The automated migrations are not necessarily perfect:
there might be some corner cases where manual changes are still required.
The tooling tries hard to avoid changes
to semantics that could affect the correctness or performance of the code.
-->
<p>この自動移行は必ずしも完璧とは限らず、手作業での変更が必要なコーナーケースもないとは言えません。
このツールは、コードの正しさやパフォーマンスに影響を与えうるような、プログラムの意味に関わる変更は避けるために全力を尽くします。</p>
<!--
In addition to tooling, we also maintain this Edition Migration Guide that covers
the changes that are part of an edition.
This guide describes each change and gives pointers to where you can learn more about it.
It also covers any corner cases or details you should be aware of.
This guide serves both as an overview of the edition
and as a quick troubleshooting reference
if you encounter problems with the automated tooling.
-->
<p>我々はこのツールの他に、エディションを構成する変更を取り扱っている、本エディション移行ガイドも管理しています。
このガイドでは、それぞれの変更内容と、もっと詳しく知りたい人向けのリンク、さらには知っておくべき詳細や重箱の隅まで網羅しています。
このガイドはエディションの概要を示すと同時に、自動化ツールに何らかの問題が生じたときのトラブルシューティング用の文献にもなります。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Creating a new project

When you create a new project with Cargo, it will automatically add
configuration for the latest edition:
-->
<h1 id="新しいプロジェクトを作成する"><a class="header" href="#新しいプロジェクトを作成する">新しいプロジェクトを作成する</a></h1>
<p>Cargoは新たなプロジェクトを作成する際に自動で最新のエディションをコンフィギュレーションに追加します。</p>
<pre><code class="language-console">&gt; cargo +nightly new foo
     Created binary (application) `foo` project
&gt; cat foo/Cargo.toml
[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;your name &lt;you@example.com&gt;&quot;]
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<!--
That `edition = "2021"` setting will configure your package to use Rust 2021.
No more configuration needed!

If you'd prefer to use an older edition, you can change the value in that
key, for example:
-->
<p>この <code>edition = &quot;2021&quot;</code> によってあなたのパッケージが Rust 2021 を利用するように設定されます。
これ以外は必要ありません。</p>
<p>もし、他の古いエディションを使いたい場合は、その設定の値を変更できます。例えば、</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;your name &lt;you@example.com&gt;&quot;]
edition = &quot;2015&quot;

[dependencies]
</code></pre>
<!--
This will build your package in Rust 2015.
-->
<p>とすると、あなたのパッケージは Rust 2015 でビルドされます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Transitioning an existing project to a new edition
-->
<h1 id="既存のプロジェクトのエディションを移行する"><a class="header" href="#既存のプロジェクトのエディションを移行する">既存のプロジェクトのエディションを移行する</a></h1>
<!--
Rust includes tooling to automatically transition a project from one edition to the next.
It will update your source code so that it is compatible with the next edition.
Briefly, the steps to update to the next edition are:
-->
<p>Rust には、プロジェクトのエディションを進めるための自動移行ツールが付属しています。
このツールは、あなたのソースコードを書き換えて次のエディションに適合させます。
簡単にいうと、新しいエディションに進むためには次のようにすればよいです。</p>
<!--
1. Run `cargo fix --edition`
2. Edit `Cargo.toml` and set the `edition` field to the next edition, for example `edition = "2021"`
3. Run `cargo build` or `cargo test` to verify the fixes worked.
-->
<ol>
<li><code>cargo fix --edition</code> を実行する</li>
<li><code>Cargo.toml</code> の <code>edition</code> フィールドを新しいエディションに設定する。たとえば、 <code>edition = &quot;2021&quot;</code> とする</li>
<li><code>cargo build</code> や <code>cargo test</code> を実行して、修正がうまくいったことを検証する。</li>
</ol>
<!--
The following sections dig into the details of these steps, and some of the issues you may encounter along the way.
-->
<p>以下のセクションで、これらの手順の詳細と、その途中で起こりうる問題点について詳しく説明します。</p>
<!--
> It's our intention that the migration to new editions is as smooth an
> experience as possible. If it's difficult for you to upgrade to the latest edition,
> we consider that a bug. If you run into problems with this process, please
> [file a bug](https://github.com/rust-lang/rust/issues/new/choose). Thank you!
-->
<blockquote>
<p>我々は、新しいエディションへの移行をできるだけスムーズに行えるようにしたいと考えています。
もし、最新のエディションにアップグレードするのが大変な場合は、我々はそれをバグとみなします。
もし移行時に問題があった場合には<a href="https://github.com/rust-lang/rust/issues/new/choose">バグ登録</a>してください。
よろしくお願いします！</p>
<p>訳注：Rustの日本語コミュニティもあります。
Slackを使用しており<a href="https://rust-jp.herokuapp.com/">こちら</a>から登録できます。</p>
</blockquote>
<!--
## Starting the migration
-->
<h2 id="移行の開始"><a class="header" href="#移行の開始">移行の開始</a></h2>
<!--
As an example, let's take a look at transitioning from the 2015 edition to the 2018 edition.
The steps are essentially the same when transitioning to other editions like 2021.
-->
<p>例えば、2015エディションから2018エディションに移行する場合を見てみましょう。
ここで説明する手順は、例えば2021エディションのように、別のエディションに移行する場合も実質的に同様です。</p>
<!--
Imagine we have a crate that has this code in `src/lib.rs`:
-->
<p><code>src/lib.rs</code>に以下のコードがあるクレートがあるとします。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, i32);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code uses an anonymous parameter, that `i32`. This is [not
supported in Rust 2018](../rust-2018/trait-system/no-anon-params.md), and
so this would fail to compile. Let's get this code up to date!
-->
<p>このコードは <code>i32</code> という無名パラメータを使用しています。
これは <a href="editions/../rust-2018/trait-system/no-anon-params.html">Rust 2018ではサポートされておらず</a>、コンパイルに失敗します。
このコードを更新してみましょう。</p>
<!--
## Updating your code to be compatible with the new edition
-->
<h2 id="あなたのコードを新しいエディションでコンパイルできるようにする"><a class="header" href="#あなたのコードを新しいエディションでコンパイルできるようにする">あなたのコードを新しいエディションでコンパイルできるようにする</a></h2>
<!--
Your code may or may not use features that are incompatible with the new edition.
In order to help transition to the next edition, Cargo includes the [`cargo fix`] subcommand to automatically update your source code.
To start, let's run it:
-->
<p>あなたのコードは新しいエディションに互換性のない機能を使っているかもしれないし、使っていないかもしれません。
Cargo には <a href="editions/../../cargo/commands/cargo-fix.html"><code>cargo fix</code></a> というサブコマンドがあり、これがあなたのコードを自動的に更新して次のエディションへの移行を補助してくれます。
まず初めに、これを実行してみましょう。</p>
<pre><code class="language-console">cargo fix --edition
</code></pre>
<!--
This will check your code, and automatically fix any issues that it can.
Let's look at `src/lib.rs` again:
-->
<p>これはあなたのコードをチェックして、自動的に移行の問題を修正してくれます。
もう一度 <code>src/lib.rs</code>を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: i32);
}
<span class="boring">}
</span></code></pre></pre>
<!--
It's re-written our code to introduce a parameter name for that `i32` value.
In this case, since it had no name, `cargo fix` will replace it with `_`,
which is conventional for unused variables.
-->
<p><code>i32</code> 値をとるパラメータに名前が追加された形でコードが書き換えられています。
この場合は、パラメータ名がなかったので、使用されていないパラメータの慣習に従って <code>_</code> を付加しています。</p>
<!--
`cargo fix` can't always fix your code automatically.
If `cargo fix` can't fix something, it will print the warning that it cannot fix
to the console. If you see one of these warnings, you'll have to update your code manually.
See the [Advanced migration strategies] chapter for more on working with the migration process, and read the chapters in this guide which explain which changes are needed.
If you have problems, please seek help at the [user's forums](https://users.rust-lang.org/).
-->
<p><code>cargo fix</code>は常に自動的にコードを修正してくれるわけではありません。
もし、<code>cargo fix</code>がコードを修正できない時にはコンソールに修正できなかったという警告を表示します。
その場合は手動でコードを修正してください。
「<a href="editions/advanced-migrations.html">発展的な移行戦略</a>」<!-- TODO: 章の名前に合わせてリンク名を変える必要があるかもしれません -->の章では、移行に関するより多くの情報があります。また、このガイドの他の章では、どのような変更が必要かについても説明しますので、併せてご参照ください。
問題が発生したときは、<a href="https://users.rust-lang.org/">ユーザーフォーラム</a> で助けを求めてください。</p>
<!--
## Enabling the new edition to use new features
-->
<h2 id="新機能を使うために新たなエディションを有効化する"><a class="header" href="#新機能を使うために新たなエディションを有効化する">新機能を使うために新たなエディションを有効化する</a></h2>
<!--
In order to use some new features, you must explicitly opt in to the new
edition. Once you're ready to continue, change your `Cargo.toml` to add the new
`edition` key/value pair. For example:
-->
<p>新しいエディションの新機能を使うには明示的にオプトインする必要があります。
準備がよければ、<code>Cargo.toml</code> に新しい <code>edition</code> のキーバリューペアを追加してください。
例えば以下のような形になります。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;
</code></pre>
<!--
If there's no `edition` key, Cargo will default to Rust 2015. But in this case,
we've chosen `2018`, and so our code will compile with Rust 2018!
-->
<p>もし <code>edition</code> キーがなければCargoはデフォルトで Rust 2015をエディションとして使います。
しかし、上記の例では <code>2018</code> を明示的に指定しているので、コードは Rust 2018 でコンパイルされます！</p>
<!--
The next step is to test your project on the new edition.
Run your project tests to verify that everything still works, such as running [`cargo test`].
If new warnings are issued, you may want to consider running `cargo fix` again (without the `--edition` flag) to apply any suggestions given by the compiler.
-->
<p>次に、新しいエディション上であなたのプロジェクトをテストしましょう。
<a href="editions/../../cargo/commands/cargo-test.html"><code>cargo test</code></a> を実行するなどして、プロジェクトのテストを走らせ、すべてが元のまま動くことを確認してください。
新たに警告が出た場合、(<code>--edition</code> なしの) <code>cargo fix</code> をもう一度実行することで、コンパイラからの提案を受け入れてみるのも良いかもしれません。</p>
<!--
Congrats! Your code is now valid in both Rust 2015 and Rust 2018!
-->
<p>わーい。今やあなたのコードは Rust 2015 と Rust 2018 の両方で有効です！</p>
<!--
[`cargo fix`]: ../../cargo/commands/cargo-fix.html
[`cargo test`]: ../../cargo/commands/cargo-test.html
[Advanced migration strategies]: advanced-migrations.md
[nightly channel]: ../../book/appendix-07-nightly-rust.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Advanced migration strategies
-->
<h1 id="発展的な移行戦略"><a class="header" href="#発展的な移行戦略">発展的な移行戦略</a></h1>
<!--
## How migrations work
-->
<h2 id="移行ツールの仕組み"><a class="header" href="#移行ツールの仕組み">移行ツールの仕組み</a></h2>
<!--
[`cargo fix --edition`][`cargo fix`] works by running the equivalent of [`cargo check`] on your project with special [lints] enabled which will detect code that may not compile in the next edition.
These lints include instructions on how to modify the code to make it compatible on both the current and the next edition.
`cargo fix` applies these changes to the source code, and then runs `cargo check` again to verify that the fixes work.
If the fixes fail, then it will back out the changes and display a warning.
-->
<p><a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix --edition</code></a> コマンドは、<a href="https://doc.rust-lang.org/cargo/commands/cargo-check.html"><code>cargo check</code></a> コマンドと同様のコマンドを、次のエディションでコンパイルされなくなるコードを検知する特別な<a href="https://doc.rust-lang.org/rustc/lints/index.html">リント</a>が有効になった状態で実行することで機能します。
このリントには、コードを変更したら現在と次のエディションの双方に適合させるための指示も含まれています。
<code>cargo fix</code> コマンドはソースコードをそれに従って変更し、再び <code>cargo check</code> を実行して修正がうまく行ったか確認します。
うまく行かなかった場合、変更を巻き戻して警告を表示します。</p>
<!--
Changing the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code.
If the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing `Cargo.toml` to use the next edition.
-->
<p>現在と次のエディションの両方に同時に適合したコードに書き換えると、コードを段階的に移行することが楽になります。
自動移行が完全には成功しなかったか、手作業で変えてやる必要がある場合は、元ののエディション留まったまま同じことを繰り返してから、<code>Cargo.toml</code> を編集して次のエディションに進めてもよいです。</p>
<!--
The lints that `cargo fix --edition` apply are part of a [lint group].
For example, when migrating from 2018 to 2021, Cargo uses the `rust-2021-compatibility` group of lints to fix the code.
Check the [Partial migration](#partial-migration-with-broken-code) section below for tips on using individual lints to help with migration.
-->
<p><code>cargo fix --edition</code> が適用するリントは、<a href="https://doc.rust-lang.org/rustc/lints/groups.html">リントグループ</a>の一部です。
例えば、2018 から 2021 に移行する場合、Cargo は <code>rust-2021-compatibility</code> というリントグループをコードの修正に使用します。
それぞれのリントを移行に役立てるコツについては、後の「<a href="editions/advanced-migrations.html#%E5%A3%8A%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%85%83%E3%81%AB%E9%83%A8%E5%88%86%E7%9A%84%E3%81%AB%E7%A7%BB%E8%A1%8C%E3%81%99%E3%82%8B">部分的な移行</a>」の章をご覧ください。</p>
<!--
`cargo fix` may run `cargo check` multiple times.
For example, after applying one set of fixes, this may trigger new warnings which require further fixes.
Cargo repeats this until no new warnings are generated.
-->
<p><code>cargo fix</code> は、<code>cargo check</code> を複数回実行する可能性があります。
たとえば、一通りの修正を終えても、修正によって新たな警告が出て、さらなる修正が必要になるかもしれません。
Cargo は、新しく警告が出なくなるまでこれを繰り返し続けます。</p>
<!--
## Migrating multiple configurations
-->
<h2 id="複数の設定を移行する"><a class="header" href="#複数の設定を移行する">複数の設定を移行する</a></h2>
<!--
`cargo fix` can only work with a single configuration at a time.
If you use [Cargo features] or [conditional compilation], then you may need to run `cargo fix` multiple times with different flags.
-->
<p><code>cargo fix</code> は一度に1つのコンフィギュレーションでしか動きません。
<a href="https://doc.rust-lang.org/cargo/reference/features.html">Cargo のフィーチャ</a>や<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">条件付きコンパイル</a>を使用している場合、<code>cargo fix</code> を異なるフラグで複数回実行する必要があるかもしれません。</p>
<!--
For example, if you have code that uses `#[cfg]` attributes to include different code for different platforms, you may need to run `cargo fix` with the `--target` option to fix for different targets.
This may require moving your code between machines if you don't have cross-compiling available.
-->
<p>例えば、あなたのコードが <code>#[cfg]</code> を使ってプラットフォームによって違うコードを含むようになっていた場合、<code>cargo fix</code> を <code>--target</code> オプションつきで実行して、ターゲットごとに修正をする必要があるかもしれません。
クロスコンパイルができない場合、コードを別のマシンに移して作業せざるを得ないかもしれません。</p>
<!--
Similarly, if you have conditions on Cargo features, like `#[cfg(feature = "my-optional-thing")]`, it is recommended to use the `--all-features` flag to allow `cargo fix` to migrate all the code behind those feature gates.
If you want to migrate feature code individually, you can use the `--features` flag to migrate one at a time.
-->
<p>同様に、フィーチャによる条件分岐、例えば <code>#[cfg(feature = &quot;my-optional-thing&quot;)]</code> のようなものがある場合、<code>--all-features</code> フラグを使って、フィーチャの壁を超えて <code>cargo fix</code> がすべてのコードを変更できるようにするとよいでしょう。
フィーチャごとに別々にコードを移行したい場合は、<code>--features</code> フラグを使って一つずつ移行作業をすることもできます。</p>
<!--
## Migrating a large project or workspace
-->
<h2 id="巨大なプロジェクトやワークスペースの移行"><a class="header" href="#巨大なプロジェクトやワークスペースの移行">巨大なプロジェクトやワークスペースの移行</a></h2>
<!--
You can migrate a large project incrementally to make the process easier if you run into problems.
-->
<p>大きなプロジェクトで問題が発生した場合、作業を単純にするために、段階的に移行していくこともできます。</p>
<!--
In a [Cargo workspace], each package defines its own edition, so the process naturally involves migrating one package at a time.
-->
<p><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo のワークスペース</a>では、エディションはパッケージごとに定義されているため、自然とパッケージごとに1つずつ移行をすることになります。</p>
<!--
Within a [Cargo package], you can either migrate the entire package at once, or migrate individual [Cargo targets] one at a time.
For example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with `cargo fix --edition` to migrate just that one target.
By default, `cargo fix` uses `--all-targets`.
-->
<p><a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-package-section">Cargo のパッケージ</a>においては、全パッケージを同時に移行することも、<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html">Cargo ターゲット</a>ごとに1つずつ移行することもできます。
例えば、パッケージに複数のバイナリ、テスト、サンプルコード（<code>example</code> ターゲット）がある場合、<code>cargo fix --edition</code> コマンドに特定のターゲット選択用のフラグを組み合わせることで、一つのターゲットだけを移行することもできます。
デフォルトでは、<code>cargo fix</code> は <code>--all-targets</code> が暗黙に指定されていると扱います。</p>
<!--
For even more advanced cases, you can specify the edition for each individual target in `Cargo.toml` like this:
-->
<p>より発展的には、<code>Cargo.toml</code> 中に各ターゲットで使用するエディションを指定することもできます:</p>
<pre><code class="language-toml">[[bin]]
name = &quot;my-binary&quot;
edition = &quot;2018&quot;
</code></pre>
<!--
This usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.
-->
<p>おそらく普通はこれは必要ありませんが、ターゲットがたくさんあって全部いっぺんに移行作業できないような場合には一つの選択肢になるでしょう。</p>
<!--
## Partial migration with broken code
-->
<h2 id="壊れたコードを元に部分的に移行する"><a class="header" href="#壊れたコードを元に部分的に移行する">壊れたコードを元に部分的に移行する</a></h2>
<!--
Sometimes the fixes suggested by the compiler may fail to work.
When this happens, Cargo will report a warning indicating what happened and what the error was.
However, by default it will automatically back out the changes it made.
It can be helpful to keep the code in the broken state and manually resolve the issue.
Some of the fixes may have been correct, and the broken fix maybe be *mostly* correct, but just need minor tweaking.
-->
<p>ときどき、コンパイラに提案された修正ではうまくいかないことがあります。
すると、Cargo は何が起こったかとどんなエラーが出たかを示す警告を報告しますが、デフォルトでは Cargo は変更を巻き戻します。
しかし、Cargo にはコードを壊れたままにしておいてもらい、手作業で問題を解決する、というのも有効な手段です。
ほとんどの修正は正しいかもしれませんし、壊れた修正も<em>だいたい</em>正しくて、少しいじれば問題ないかもしれないのです。</p>
<!--
In this situation, use the `--broken-code` option with `cargo fix` to tell Cargo not to back out the changes.
Then, you can go manually inspect the error and investigate what is needed to fix it.
-->
<p>そんなときは、<code>cargo fix</code> コマンドを実行するときに <code>--broken-code</code> オプションをつけて、Cargo が変更を巻き戻さないようにできます。
そうすれば、エラーを実際に見てみることも、修正点を確認することもできます。</p>
<!--
Another option to incrementally migrate a project is to apply individual fixes separately, one at a time.
You can do this by adding the individual lints as warnings, and then either running `cargo fix` (without the `--edition` flag) or using your editor or IDE to apply its suggestions if it supports "Quick Fixes".
-->
<p>プロジェクトを段階的に移行するもう一つの方法は、それぞれの修正を一つずつ適用することです。
このためには、各リントを警告として追加して、（<code>--edition</code> なしの）<code>cargo fix</code> を実行するか、お手持ちのエディタや IDE が「クイックフィックス」をサポートしていればそれを使って提案を適用すればよいです。</p>
<!--
For example, the 2018 edition uses the [`keyword-idents`] lint to fix any conflicting keywords.
You can add `#![warn(keyword_idents)]` to the top of each crate (like at the top of `src/lib.rs` or `src/main.rs`).
Then, running `cargo fix` will apply just the suggestions for that lint.
-->
<p>例えば、2018 エディションには <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#keyword-idents"><code>keyword-idents</code></a> という、キーワードとの衝突をすべて修正するためのリントがあります。
各クレートのトップ（例えば <code>src/lib.rs</code> や <code>src/main.rs</code> の先頭）に <code>#![warn(keyword_idents)]</code> を追加して、<code>cargo fix</code> を実行すれば、そのリントによる提案だけを受け入れることができます。</p>
<!--
You can see the list of lints enabled for each edition in the [lint group] page, or run the `rustc -Whelp` command.
-->
<p>各エディションで有効化されるリントの一覧は、<a href="https://doc.rust-lang.org/rustc/lints/groups.html">リントグループ</a>のページを見るか、 <code>rustc -Whelp</code> コマンドを実行すれば確認できます。</p>
<!--
## Migrating macros
-->
<h2 id="マクロの移行"><a class="header" href="#マクロの移行">マクロの移行</a></h2>
<!--
Some macros may require manual work to fix them for the next edition.
For example, `cargo fix --edition` may not be able to automatically fix a macro that generates syntax that does not work in the next edition.
-->
<p>マクロの中には、エディションを進めるにあたって手作業が必要なものがあります。
例えば、<code>cargo fix --edition</code> は、次のエディションで動作しない文法を生成するマクロを自動修正することは難しいかもしれません。</p>
<!--
This may be a problem for both [proc macros] and `macro_rules`-style macros.
`macro_rules` macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot.
Proc macros in general cannot be automatically fixed at all.
-->
<p>これは、<a href="https://doc.rust-lang.org/reference/procedural-macros.html">手続き型マクロ</a>と <code>macro_rules</code> を使ったマクロの双方で問題になります。
<code>macro_rules</code> を使ったマクロは、マクロが同じクレートに属していたら自動でアップデートできる場合もありますが、いくつかの状況ではできません。
手続き型マクロは原則、全く修正できないと言っていいでしょう。</p>
<!--
For example, if we migrate a crate containing this (contrived) macro `foo` from 2015 to 2018, `foo` would not be automatically fixed.
-->
<p>例えば、この（わざとらしい）マクロ <code>foo</code> を含むクレートを 2015 から 2018 に移行しようとしても、<code>foo</code> は自動修復されません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    () =&gt; {
        let dyn = 1;
        println!(&quot;it is {}&quot;, dyn);
              // &quot;これは {} です&quot;
    };
}
<span class="boring">}
</span></code></pre></pre>
<!--
When this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below).
In 2015, `dyn` is a normal identifier and can be used without restriction.
-->
<p>マクロが 2015 のクレートで定義されている場合、マクロの衛生性（後述）のおかげでこれは他のエディションのクレートからも使用することができます。
2015 では、<code>dyn</code> は通常の識別子で、制限なく使用できます。</p>
<!--
However, in 2018, `dyn` is no longer a valid identifier.
When using `cargo fix --edition` to migrate to 2018, Cargo won't display any warnings or errors at all.
However, `foo` won't work when called from any crate.
-->
<p>一方で、2018 では、<code>dyn</code> はもはや正当な識別子ではありません。
<code>cargo fix --edition</code> で 2018 へ移行するとき、Cargo は警告やエラーを一切表示しません。
しかし、<code>foo</code> はどのクレートで呼び出されても動作しません。</p>
<!--
If you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax.
You may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere.
If you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.
-->
<p>あなたのコードにマクロがある場合、そのマクロの構文を十分に網羅するテストがあることが推奨されます。
また、そのマクロを複数のエディションのクレートの中でインポートして使用し、どこでも動くということを確認するのも良いでしょう。
問題に突き当たった場合、このガイドの本章に目を通して、全エディションで動作するようにするためにどうすればいいか理解する必要があります。</p>
<!--
### Macro hygiene
-->
<h3 id="マクロの衛生性"><a class="header" href="#マクロの衛生性">マクロの衛生性</a></h3>
<!--
Macros use a system called "edition hygiene" where the tokens within a macro are marked with which edition they come from.
This allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.
-->
<p>マクロには、「エディション衛生性」と呼ばれる仕組みが使われています。このシステムでは、マクロ内のトークンがどのエディションから来たかが記録されています。
これにより、呼び出す側のエディションがどれであるかを気にせずに、外部のマクロを呼び出すことができます。</p>
<!--
Let's take a closer look at the example above that defines a `macro_rules` macro using `dyn` as an identifier.
If that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where `dyn` is a keyword and that would normally be a syntax error.
The `let dyn = 1;` tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded.
The parser looks at the edition of the tokens to know how to interpret it.
-->
<p>上で例に出した、<code>macro_rules</code> で定義されたマクロを詳しく見てみましょう。
このマクロは <code>dyn</code> を識別子に使用しています。
このマクロが定義されているのが 2015 エディションのクレート内なのならば、これは問題なく動きます。
さらに、2018 エディションでは <code>dyn</code> はキーワードで普通は識別子に使えませんが、2018 エディションのクレートからこのマクロを呼び出したとしても大丈夫です。
パーサーはトークンのエディションに着目して、どう解釈したらよいかを判断します。</p>
<!--
The problem arises when changing the edition to 2018 in the crate where it is defined.
Now, those tokens are tagged with the 2018 edition, and those will fail to parse.
However, since we never called the macro from our crate, `cargo fix --edition` never had a chance to inspect the macro and fix it.
-->
<p>問題が起こるのは、マクロが定義されている側のクレートのエディションを 2018 に変更したときです。
今や、これらのトークンは 2018 エディションのものとしてタグ付けされているために、パースに失敗します。
しかしながら、このマクロは自身のクレートから呼び出されてもいないために、<code>cargo fix --edition</code> はこれを検査することも修正することもできません。</p>
<!--
--> <!-- 原文にはここに TODO コメントがあります。左側の不自然なコメントは、 mdbook-transcheck で差分が出ないようにするためです -->
<!--
## Documentation tests
-->
<h2 id="ドキュメンテーションテスト"><a class="header" href="#ドキュメンテーションテスト">ドキュメンテーションテスト</a></h2>
<!--
At this time, `cargo fix` is not able to update [documentation tests].
After updating the edition in `Cargo.toml`, you should run `cargo test` to ensure everything still passes.
If your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.
-->
<p>現在のところ、<code>cargo fix</code> は<a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">ドキュメンテーションテスト</a>を更新することはできません。
<code>Cargo.toml</code> でエディションを更新したら、<code>cargo test</code> を実行して全てのテストに通過することを確認すべきです。
新しいエディションでサポートされない構文がドキュメンテーションテストに使われていた場合は、手作業で修正する必要があります。</p>
<!--
In rare cases, you can manually set the edition for each test.
For example, you can use the [`edition2018` annotation][rustdoc-annotation] on the triple backticks to tell `rustdoc` which edition to use.
-->
<p>まれなケースですが、エディションをテストごとに設定することもできます。
例えば、バッククォート3つの後に <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html#attributes"><code>edition2018</code> アノテーション</a>をつければ、<code>rustdoc</code> が使うエディションを指定できます。</p>
<!--
## Generated code
-->
<h2 id="生成されるコード"><a class="header" href="#生成されるコード">生成されるコード</a></h2>
<!--
Another area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see [Code generation] for an example).
In this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.
-->
<p>自動移行が使えない場所がもう一つあります。それは、ビルドスクリプトが Rust コードをコンパイル時に生成する場合です（具体例は「<a href="https://doc.rust-lang.org/cargo/reference/build-script-examples.html#code-generation">コード生成</a>」をご参照ください）。
このとき、出てくるコードが次のエディションで機能しない場合は、生成されるコードが新しいエディションに適合するように、ビルドスクリプトを自分で書き換える必要があります。</p>
<!--
## Migrating non-Cargo projects
-->
<h2 id="cargo-でないプロジェクトの移行"><a class="header" href="#cargo-でないプロジェクトの移行">Cargo でないプロジェクトの移行</a></h2>
<!--
If your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition.
You can enable the migration lints as described above by enabling the appropriate [lint group].
For example, you can use the `#![warn(rust_2021_compatibility)]` attribute or the `-Wrust-2021-compatibility` or `--force-warns=rust-2021-compatibility` [CLI flag].
-->
<p>プロジェクトのビルドシステムが Cargo 以外の場合でも、次のエディションへの移行に自動リントが利用できるかもしれません。
適切な<a href="https://doc.rust-lang.org/rustc/lints/groups.html">リントグループ</a>を使って、前述の移行リントを有効化できます。
例えば、<code>#![warn(rust_2021_compatibility)]</code> というアトリビュートを使ったり、<code>-Wrust-2021-compatibility</code> や <code>--force-warns=rust-2021-compatibility</code> などの <a href="https://doc.rust-lang.org/rustc/lints/levels.html#via-compiler-flag">CLI フラグ</a>を使用するとよいです。</p>
<!--
The next step is to apply those lints to your code.
There are several options here:
-->
<p>次に、これらのリントをコードに適用します。
これにはいくつかの手があります:</p>
<!--
* Manually read the warnings and apply the suggestions recommended by the compiler.
* Use an editor or IDE that supports automatically applying suggestions.
  For example, [Visual Studio Code] with the [Rust Analyzer extension] has the ability to use the "Quick Fix" links to automatically apply suggestions.
  Many other editors and IDEs have similar functionality.
* Write a migration tool using the [`rustfix`] library.
  This is the library that Cargo uses internally to take the [JSON messages] from the compiler and modify the source code.
  Check the [`examples` directory][rustfix-examples] for examples of how to use the library.
-->
<ul>
<li>警告を読んで、コンパイラに提案された変更を自分で加える。</li>
<li>エディタや IDE の機能で、コンパイラからの提案を適用する。
例えば、<a href="https://code.visualstudio.com/">Visual Studio Code</a> で <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">Rust Analyzer 拡張</a> を使えば、自動的に提案を受け入れるための「クイックフィックス」が使えます。
他にも多くのエディタで同様の機能が使えます。</li>
<li><a href="https://github.com/rust-lang/rustfix"><code>rustfix</code></a> ライブラリを用いて、移行ツールを自作する。
このライブラリは Cargo 内部でも使われており、コンパイラからの <a href="https://doc.rust-lang.org/rustc/json.html">JSON メッセージ</a>を元にソースコードを編集します。
ライブラリの使用例は、<a href="https://github.com/rust-lang/rustfix/tree/master/examples"><code>examples</code> ディレクトリ</a>をご覧ください。</li>
</ul>
<!--
## Writing idiomatic code in a new edition
-->
<h2 id="新しいエディションで慣用的な書き方をする"><a class="header" href="#新しいエディションで慣用的な書き方をする">新しいエディションで慣用的な書き方をする</a></h2>
<!--
Editions are not only about new features and removing old ones.
In any programming language, idioms change over time, and Rust is no exception.
While old code will continue to compile, it might be written with different idioms today.
-->
<p>エディションは、新機能の追加や古い機能の削除のためだけのものではありません。
どんなプログラミング言語でも、その言語らしい書き方は時代によって変化します。Rust も同じです。
古いプログラムはコンパイルには通るかもしれませんが、今は別の書き方があるかもしれません。</p>
<!--
For example, in Rust 2015, external crates must be listed with `extern crate` like this:
-->
<p>例えば、Rust 2015 では、外部クレートは以下のように <code>extern crate</code> で明示的に宣言される必要がありました:</p>
<pre><code class="language-rust ignore">// src/lib.rs
extern crate rand;
</code></pre>
<!--
In Rust 2018, it is [no longer necessary](../rust-2018/path-changes.md#no-more-extern-crate) to include these items.
-->
<p>Rust 2018 では、外部クレートを使うのに<a href="editions/../rust-2018/path-changes.html#no-more-extern-crate"><code>extern crate</code> は必要ありません</a>。</p>
<!--
`cargo fix` has the `--edition-idioms` option to automatically transition some of these idioms to the new syntax.
-->
<p><code>cargo fix</code> には <code>--edition-idioms</code> オプションがあり、古い<ruby>書き方<rp>(</rp><rt>イディオム</rt><rp>)</rp></ruby>の一部を新しい書き方に書き換えることができます。</p>
<!--
> **Warning**: The current *"idiom lints"* are known to have some problems.
> They may make incorrect suggestions which may fail to compile.
> The current lints are:
> * Edition 2018:
>     * [`unused-extern-crates`]
>     * [`explicit-outlives-requirements`]
> * Edition 2021 does not have any idiom lints.
>
> The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs!
> If you run into problems, you can try the `--broken-code` option [described above](#partial-migration-with-broken-code) to make as much progress as possible, and then resolve the remaining issues manually.
-->
<blockquote>
<p><strong>警告</strong>: 現行の<!-- --><em>「イディオムリント」</em><!-- -->にはいくつか問題があることが知られています。
これらのリントはときどき、受け入れるとコンパイルできなくなるような誤った提案をすることがあります。
現在、以下のリントがあります。</p>
<ul>
<li>Edition 2018:
<ul>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unused-extern-crates"><code>unused-extern-crates</code></a></li>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements"><code>explicit-outlives-requirements</code></a></li>
</ul>
</li>
<li>Edition 2021 にイディオムリントはありません。</li>
</ul>
<p>以下の手順は、コンパイラや Cargo の多少のバグを厭わない恐れ知らずだけにしかお勧めできません！　
不都合が発生する場合は、<a href="editions/advanced-migrations.html#%E5%A3%8A%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%85%83%E3%81%AB%E9%83%A8%E5%88%86%E7%9A%84%E3%81%AB%E7%A7%BB%E8%A1%8C%E3%81%99%E3%82%8B">前述</a>の <code>--broken-code</code> オプションを使ってツールにやれるだけのことをさせ、残った問題を自分の手で解決してもよいでしょう。</p>
</blockquote>
<!--
With that out of the way, we can instruct Cargo to fix our code snippet with:
-->
<p>ともあれ、先程の短いコードを Cargo に直してもらうにはこうすればよいです:</p>
<pre><code class="language-console">cargo fix --edition-idioms
</code></pre>
<!--
Afterwards, the line with `extern crate rand;` in `src/lib.rs` will be removed.
-->
<p>すると、<code>src/lib.rs</code> に書かれた <code>extern crate rand;</code> が削除されます。</p>
<!--
We're now more idiomatic, and we didn't have to fix our code manually!
-->
<p>これで、自分でコードに手を下すことなく、コードを現代風にできました！</p>
<!--
[`cargo check`]: ../../cargo/commands/cargo-check.html
[`cargo fix`]: ../../cargo/commands/cargo-fix.html
[`explicit-outlives-requirements`]:  ../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements
[`keyword-idents`]: ../../rustc/lints/listing/allowed-by-default.html#keyword-idents
[`rustfix`]: https://github.com/rust-lang/rustfix
[`unused-extern-crates`]: ../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates
[Cargo features]: ../../cargo/reference/features.html
[Cargo package]: ../../cargo/reference/manifest.html#the-package-section
[Cargo targets]: ../../cargo/reference/cargo-targets.html
[Cargo workspace]: ../../cargo/reference/workspaces.html
[CLI flag]: ../../rustc/lints/levels.html#via-compiler-flag
[Code generation]: ../../cargo/reference/build-script-examples.html#code-generation
[conditional compilation]: ../../reference/conditional-compilation.html
[documentation tests]: ../../rustdoc/documentation-tests.html
[JSON messages]: ../../rustc/json.html
[lint group]: ../../rustc/lints/groups.html
[lints]: ../../rustc/lints/index.html
[proc macros]: ../../reference/procedural-macros.html
[Rust Analyzer extension]: https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer
[rustdoc-annotation]: ../../rustdoc/documentation-tests.html#attributes
[rustfix-examples]: https://github.com/rust-lang/rustfix/tree/master/examples
[Visual Studio Code]: https://code.visualstudio.com/
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-2015"><a class="header" href="#rust-2015">Rust 2015</a></h1>
<!--
Rust 2015 has a theme of "stability". It commenced with the release of 1.0,
and is the "default edition". The edition system was conceived in late 2017,
but Rust 1.0 was released in May of 2015. As such, 2015 is the edition
that you get when you don't specify any particular edition, for backwards
compatibility reasons.
-->
<p>Rust 2015は「安定性」というテーマを掲げています。
このエディションはRust 1.0のリリースから始まり、デフォルトのエディションとなっています。
エディションの仕組み自体は2017年末に考案されましたが、Rust 1.0は2015年5月にリリースされていて、「2015」が特定のエディションを指定しなかった時のデフォルトになります。</p>
<!--
"Stability" is the theme of Rust 2015 because 1.0 marked a huge change in
Rust development. Previous to Rust 1.0, Rust was changing on a daily basis.
This made it very difficult to write large software in Rust, and made it
difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed
to backwards compatibility, ensuring a solid foundation for people to build
projects on top of.
-->
<p>「安定性」がRust 2015エディションのテーマです。
なぜなら、Rust 1.0はRust開発に著しい変化をもたらしたからです。
Rust 1.0以前は、Rustは毎日のように変わっていました。
そのような言語は大規模なソフトウエア開発には使えないですし、学ぶことも難しいでしょう。
Rust 1.0とRust 2015エディションの登場とともに、我々は後方互換性にコミットし、Rust上で開発を行う人々のための強固な基盤を提供しています。</p>
<!--
Since it's the default edition, there's no way to port your code to Rust
2015; it just *is*. You'll be transitioning *away* from 2015, but never
really *to* 2015. As such, there's not much else to say about it!
-->
<p>Rust 2015はデフォルトのエディションなのであなたのコードをRust 2015へポーティングするということはありません。
どんなRustのコードもRust 2015<em>です</em>。
あなたは Rust 2015から<em>離れる</em>ことはあっても、<em>近づいていく</em>ということはありません。
ということで、これ以上あまり言うことはないでしょう！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-2018"><a class="header" href="#rust-2018">Rust 2018</a></h1>
<!--
| Info | |
| --- | --- |
| RFC | [#2052](https://rust-lang.github.io/rfcs/2052-epochs.html), which also proposed the Edition system |
| Release version | [1.31.0](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html) |
-->
<table><thead><tr><th>情報</th><th></th></tr></thead><tbody>
<tr><td>RFC</td><td><a href="https://rust-lang.github.io/rfcs/2052-epochs.html">#2052</a> (このRFCはエディションシステムそのものも提案している)</td></tr>
<tr><td>リリースバージョン</td><td><a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">1.31.0</a></td></tr>
</tbody></table>
<!--
The edition system was created for the release of Rust 2018. The release of the Rust 2018 edition coincided with a number of other features all coordinated around the theme of *productivity*. The majority of those features were backwards compatible and are now available on all editions; however, some of those changes required the edition mechanism (most notably the [module system changes](path-changes.md)).
-->
<p>Rust 2018 のリリースのために、エディションシステムが作られました。
Rust 2018 のリリースは、<em>生産性</em>をテーマに掲げた数々の新機能とともにもたらされました。
ほとんどの新機能には後方互換性があり、すべてのエディションで使用可能となりました。
一方、一部の変更にはエディション機構が必要となりました（代表例は<a href="rust-2018/path-changes.html">モジュールシステムの変更</a>です）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-and-module-system-changes"><a class="header" href="#path-and-module-system-changes">Path and module system changes</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Paths in <code>use</code> declarations now work the same as other paths.</li>
<li>Paths starting with <code>::</code> must now be followed with an external crate.</li>
<li>Paths in <code>pub(in path)</code> visibility modifiers must now start with <code>crate</code>, <code>self</code>, or <code>super</code>.</li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The module system is often one of the hardest things for people new to Rust. Everyone
has their own things that take time to master, of course, but there's a root
cause for why it's so confusing to many: while there are simple and
consistent rules defining the module system, their consequences can feel
inconsistent, counterintuitive and mysterious.</p>
<p>As such, the 2018 edition of Rust introduces a few new module system
features, but they end up <em>simplifying</em> the module system, to make it more
clear as to what is going on.</p>
<p>Here's a brief summary:</p>
<ul>
<li><code>extern crate</code> is no longer needed in 99% of circumstances.</li>
<li>The <code>crate</code> keyword refers to the current crate.</li>
<li>Paths may start with a crate name, even within submodules.</li>
<li>Paths starting with <code>::</code> must reference an external crate.</li>
<li>A <code>foo.rs</code> and <code>foo/</code> subdirectory may coexist; <code>mod.rs</code> is no longer needed
when placing submodules in a subdirectory.</li>
<li>Paths in <code>use</code> declarations work the same as other paths.</li>
</ul>
<p>These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall. Read on for more details!</p>
<h2 id="more-details"><a class="header" href="#more-details">More details</a></h2>
<p>Let's talk about each new feature in turn.</p>
<h3 id="no-more-extern-crate"><a class="header" href="#no-more-extern-crate">No more <code>extern crate</code></a></h3>
<p>This one is quite straightforward: you no longer need to write <code>extern crate</code> to
import a crate into your project. Before:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}
</code></pre>
<p>Now, to add a new crate to your project, you can add it to your <code>Cargo.toml</code>,
and then there is no step two. If you're not using Cargo, you already had to pass
<code>--extern</code> flags to give <code>rustc</code> the location of external crates, so you'd just
keep doing what you were doing there as well.</p>
<blockquote>
<p>One small note here: <code>cargo fix</code> will not currently automate this change. We may
have it do this for you in the future.</p>
</blockquote>
<h4 id="an-exception"><a class="header" href="#an-exception">An exception</a></h4>
<p>There's one exception to this rule, and that's the &quot;sysroot&quot; crates. These are the
crates distributed with Rust itself.</p>
<p>Usually these are only needed in very specialized situations. Starting in
1.41, <code>rustc</code> accepts the <code>--extern=CRATE_NAME</code> flag which automatically adds
the given crate name in a way similar to <code>extern crate</code>. Build tools may use
this to inject sysroot crates into the crate's prelude. Cargo does not have a
general way to express this, though it uses it for <code>proc_macro</code> crates.</p>
<p>Some examples of needing to explicitly import sysroot crates are:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/index.html"><code>std</code></a>: Usually this is not neccesary, because <code>std</code> is automatically
imported unless the crate is marked with <a href="https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute"><code>#![no_std]</code></a>.</li>
<li><a href="https://doc.rust-lang.org/core/index.html"><code>core</code></a>: Usually this is not necessary, because <code>core</code> is automatically
imported, unless the crate is marked with <a href="https://github.com/rust-lang/rust/issues/29639"><code>#![no_core]</code></a>. For
example, some of the internal crates used by the standard library itself
need this.</li>
<li><a href="https://doc.rust-lang.org/proc_macro/index.html"><code>proc_macro</code></a>: This is automatically imported by Cargo if it is a
proc-macro crate starting in 1.42. <code>extern crate proc_macro;</code> would be
needed if you want to support older releases, or if using another build tool
that does not pass the appropriate <code>--extern</code> flags to <code>rustc</code>.</li>
<li><a href="https://doc.rust-lang.org/alloc/index.html"><code>alloc</code></a>: Items in the <code>alloc</code> crate are usually accessed via re-exports in
the <code>std</code> crate. If you are working with a <code>no_std</code> crate that supports
allocation, then you may need to explicitly import <code>alloc</code>.</li>
<li><a href="https://doc.rust-lang.org/test/index.html"><code>test</code></a>: This is only available on the <a href="https://doc.rust-jp.rs/book-ja/appendix-07-nightly-rust.html">nightly channel</a>, and is usually
only used for the unstable benchmark support.</li>
</ul>
<!--
[`alloc`]: ../../alloc/index.html
[`core`]: ../../core/index.html
[`proc_macro`]: ../../proc_macro/index.html
[`std`]: ../../std/index.html
[`test`]: ../../test/index.html
[nightly channel]: ../../book/appendix-07-nightly-rust.html
[no_core]: https://github.com/rust-lang/rust/issues/29639
[no_std]: ../../reference/names/preludes.html#the-no_std-attribute
-->
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<p>One other use for <code>extern crate</code> was to import macros; that's no longer needed.
Macros may be imported with <code>use</code> like any other item. For example, the
following use of <code>extern crate</code>:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate bar;

fn main() {
    baz!();
}
</code></pre>
<p>Can be changed to something like the following:</p>
<pre><code class="language-rust ignore">use bar::baz;

fn main() {
    baz!();
}
</code></pre>
<h4 id="renaming-crates"><a class="header" href="#renaming-crates">Renaming crates</a></h4>
<p>If you've been using <code>as</code> to rename your crate like this:</p>
<pre><code class="language-rust ignore">extern crate futures as f;

use f::Future;
</code></pre>
<p>then removing the <code>extern crate</code> line on its own won't work. You'll need to do this:</p>
<pre><code class="language-rust ignore">use futures as f;

use self::f::Future;
</code></pre>
<p>This change will need to happen in any module that uses <code>f</code>.</p>
<h3 id="the-crate-keyword-refers-to-the-current-crate"><a class="header" href="#the-crate-keyword-refers-to-the-current-crate">The <code>crate</code> keyword refers to the current crate</a></h3>
<p>In <code>use</code> declarations and in other code, you can refer to the root of the
current crate with the <code>crate::</code> prefix. For instance, <code>crate::foo::bar</code> will
always refer to the name <code>bar</code> inside the module <code>foo</code>, from anywhere else in
the same crate.</p>
<p>The prefix <code>::</code> previously referred to either the crate root or an external
crate; it now unambiguously refers to an external crate. For instance,
<code>::foo::bar</code> always refers to the name <code>bar</code> inside the external crate <code>foo</code>.</p>
<h3 id="extern-crate-paths"><a class="header" href="#extern-crate-paths">Extern crate paths</a></h3>
<p>Previously, using an external crate in a module without a <code>use</code> import
required a leading <code>::</code> on the path.</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate chrono;

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // but in a submodule it requires a leading :: if not imported with `use`
        let x = ::chrono::Utc::now();
    }
}
</code></pre>
<p>Now, extern crate names are in scope in the entire crate, including
submodules.</p>
<pre><code class="language-rust ignore">// Rust 2018

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // crates may be referenced directly, even in submodules
        let x = chrono::Utc::now();
    }
}
</code></pre>
<h3 id="no-more-modrs"><a class="header" href="#no-more-modrs">No more <code>mod.rs</code></a></h3>
<p>In Rust 2015, if you have a submodule:</p>
<pre><code class="language-rust ignore">// This `mod` declaration looks for the `foo` module in
// `foo.rs` or `foo/mod.rs`.
mod foo;
</code></pre>
<p>It can live in <code>foo.rs</code> or <code>foo/mod.rs</code>. If it has submodules of its own, it
<em>must</em> be <code>foo/mod.rs</code>. So a <code>bar</code> submodule of <code>foo</code> would live at
<code>foo/bar.rs</code>.</p>
<p>In Rust 2018 the restriction that a module with submodules must be named
<code>mod.rs</code> is lifted. <code>foo.rs</code> can just be <code>foo.rs</code>,
and the submodule is still <code>foo/bar.rs</code>. This eliminates the special
name, and if you have a bunch of files open in your editor, you can clearly
see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>
<table>
  <thead>
    <tr>
      <th>Rust 2015</th>
      <th>Rust 2018</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
<pre>
.
├── lib.rs
└── foo/
    ├── mod.rs
    └── bar.rs
</pre>
    </td>
    <td>
<pre>
.
├── lib.rs
├── foo.rs
└── foo/
    └── bar.rs
</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="use-paths"><a class="header" href="#use-paths"><code>use</code> paths</a></h3>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<p>Rust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust
2015, paths work differently in <code>use</code> declarations than they do elsewhere. In
particular, paths in <code>use</code> declarations would always start from the crate
root, while paths in other code implicitly started from the current scope.
Those differences didn't have any effect in the top-level module, which meant
that everything would seem straightforward until working on a project large
enough to have submodules.</p>
<p>In Rust 2018, paths in <code>use</code> declarations and in other code work the same way,
both in the top-level module and in any submodule. You can use a relative path
from the current scope, a path starting from an external crate name, or a path
starting with <code>crate</code>, <code>super</code>, or <code>self</code>.</p>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>will look exactly the same in Rust 2018, except that you can delete the <code>extern crate</code> line:</p>
<pre><code class="language-rust ignore">// Rust 2018

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>The same code will also work completely unmodified in a submodule:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;

    mod foo {
        pub struct Bar;
    }

    use foo::Bar;

    fn my_poll() -&gt; futures::Poll { ... }

    enum SomeEnum {
        V1(usize),
        V2(String),
    }

    fn func() {
        let five = std::sync::Arc::new(5);
        use SomeEnum::*;
        match ... {
            V1(i) =&gt; { ... }
            V2(s) =&gt; { ... }
        }
    }
}
</code></pre>
<p>This makes it easy to move code around in a project, and avoids introducing
additional complexity to multi-module projects.</p>
<p>If a path is ambiguous, such as if you have an external crate and a local
module or item with the same name, you'll get an error, and you'll need to
either rename one of the conflicting names or explicitly disambiguate the path.
To explicitly disambiguate a path, use <code>::name</code> for an external crate name, or
<code>self::name</code> for a local module or item.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Anonymous trait function parameters deprecated
-->
<h1 id="トレイト関数の匿名パラメータの非推奨化"><a class="header" href="#トレイト関数の匿名パラメータの非推奨化">トレイト関数の匿名パラメータの非推奨化</a></h1>
<!--
![Minimum Rust version: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/%E5%B0%8E%E5%85%A5%20Rust%20%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3-1.31-brightgreen.svg" alt="導入 Rust バージョン: 1.31" /></p>
<!--
## Summary
-->
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<!--
- [Trait function parameters] may use any irrefutable pattern when the function has a body.
-->
<ul>
<li>関数に本体があるとき、<a href="https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns">トレイト関数のパラメータ</a>は、任意の論駁不可能なパターンを使えます。</li>
</ul>
<!--
[Trait function parameters]: https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns
-->
<!--
## Details
-->
<h2 id="詳細"><a class="header" href="#詳細">詳細</a></h2>
<!--
In accordance with RFC [#1685](https://github.com/rust-lang/rfcs/pull/1685),
parameters in trait method declarations are no longer allowed to be anonymous.
-->
<p>RFC <a href="https://github.com/rust-lang/rfcs/pull/1685">#1685</a>に基づいて、トレイト関数のパラメータを匿名にすることはできなくなりました。</p>
<!--
For example, in the 2015 edition, this was allowed:
-->
<p>例えば、2015 エディションでは、以下のように書けました:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, u8);
}
<span class="boring">}
</span></code></pre></pre>
<!--
In the 2018 edition, all parameters must be given an argument name  (even if it's just
`_`):
-->
<p>2018 エディションでは、すべての引数名に（ただの <code>_</code> であってもいいので、何らかの）名前がついていなければなりません:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, baz: u8);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-keywords"><a class="header" href="#new-keywords">New keywords</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li><code>dyn</code> is a <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keyword</a>, in 2015 it is a <a href="https://doc.rust-lang.org/reference/keywords.html#weak-keywords">weak keyword</a>.</li>
<li><code>async</code> and <code>await</code> are <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keywords</a>.</li>
<li><code>try</code> is a <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved keyword</a>.</li>
</ul>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<h3 id="dyn-trait-for-trait-objects"><a class="header" href="#dyn-trait-for-trait-objects"><code>dyn Trait</code> for trait objects</a></h3>
<p>The <code>dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<p>And so on. In code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

// old
fn function1() -&gt; Box&lt;Trait&gt; {
<span class="boring">unimplemented!()
</span>}

// new
fn function2() -&gt; Box&lt;dyn Trait&gt; {
<span class="boring">unimplemented!()
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>That's it!</p>
<h4 id="why"><a class="header" href="#why">Why?</a></h4>
<p>Using just the trait name for trait objects turned out to be a bad decision.
The current syntax is often ambiguous and confusing, even to veterans,
and favors a feature that is not more frequently used than its alternatives,
is sometimes slower, and often cannot be used at all when its alternatives can.</p>
<p>Furthermore, with <code>impl Trait</code> arriving, &quot;<code>impl Trait</code> vs <code>dyn Trait</code>&quot; is much
more symmetric, and therefore a bit nicer, than &quot;<code>impl Trait</code> vs <code>Trait</code>&quot;.
<code>impl Trait</code> is explained <a href="https://doc.rust-jp.rs/rust-by-example-ja/rust-by-example/trait/impl_trait.html">here</a>.</p>
<p>In the new edition, you should therefore prefer <code>dyn Trait</code> to just <code>Trait</code>
where you need a trait object.</p>
<!--
[impl-trait]: ../../rust-by-example/trait/impl_trait.html
-->
<h3 id="async-and-await"><a class="header" href="#async-and-await"><code>async</code> and <code>await</code></a></h3>
<p>These keywords are reserved to implement the async-await feature of Rust, which was ultimately <a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">released to stable in 1.39.0</a>.</p>
<h3 id="try-keyword"><a class="header" href="#try-keyword"><code>try</code> keyword</a></h3>
<p>The <code>try</code> keyword is reserved for use in <code>try</code> blocks, which have not (as of this writing) been stabilized (<a href="https://github.com/rust-lang/rust/issues/31436">tracking issue</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-dispatch-for-raw-pointers-to-inference-variables"><a class="header" href="#method-dispatch-for-raw-pointers-to-inference-variables">Method dispatch for raw pointers to inference variables</a></h1>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ul>
<li>The <a href="https://github.com/rust-lang/rust/issues/46906"><code>tyvar_behind_raw_pointer</code></a> lint is now a hard error.</li>
</ul>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>See Rust issue <a href="https://github.com/rust-lang/rust/issues/46906">#46906</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-changes"><a class="header" href="#cargo-changes">Cargo changes</a></h1>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ul>
<li>If there is a target definition in a <code>Cargo.toml</code> manifest, it no longer
automatically disables automatic discovery of other targets.</li>
<li>Target paths of the form <code>src/{target_name}.rs</code> are no longer inferred for
targets where the <code>path</code> field is not set.</li>
<li><code>cargo install</code> for the current directory is no longer allowed, you must
specify <code>cargo install --path .</code> to install the current package.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-2021"><a class="header" href="#rust-2021">Rust 2021</a></h1>
<!--
| Info | |
| --- | --- |
| RFC | [#3085](https://github.com/rust-lang/rfcs/pull/3085) |
| Release version | 1.56.0 |
-->
<table><thead><tr><th>情報</th><th></th></tr></thead><tbody>
<tr><td>RFC</td><td><a href="https://github.com/rust-lang/rfcs/pull/3085">#3085</a></td></tr>
<tr><td>リリースバージョン</td><td>1.56.0</td></tr>
</tbody></table>
<!--
The Rust 2021 Edition contains several changes that bring new capabilities and more consistency to the language,
and opens up room for expansion in the future.
The following chapters dive into the details of each change,
and they include guidance on migrating your existing code.
-->
<p>Rust 2021 エディションでは、新機能を追加し、言語をより一貫したものにして、
さらに将来の拡張性の余地を広げるための、いくつかの変更がなされています。
以下の章ではこれらの変更の詳細を見ていくと同時に、
既存のコードを移行するためのガイドも示していきます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Additions to the prelude
-->
<h1 id="prelude-への追加"><a class="header" href="#prelude-への追加">Prelude への追加</a></h1>
<!--
## Summary
-->
<h2 id="概要-1"><a class="header" href="#概要-1">概要</a></h2>
<!--
- The `TryInto`, `TryFrom` and `FromIterator` traits are now part of the prelude.
- This might make calls to trait methods ambiguous which could make some code fail to compile.
-->
<ul>
<li><code>TryInto</code>, <code>TryFrom</code>, <code>FromIterator</code> トレイトがプレリュードに追加されました。</li>
<li>これにより、トレイトメソッドへの呼び出しに曖昧性が発生して、コンパイルに失敗するようになるコードがあるかもしれません。</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-1"><a class="header" href="#詳細-1">詳細</a></h2>
<!--
The [prelude of the standard library](https://doc.rust-lang.org/stable/std/prelude/index.html)
is the module containing everything that is automatically imported in every module.
It contains commonly used items such as `Option`, `Vec`, `drop`, and `Clone`.
-->
<p><a href="https://doc.rust-lang.org/stable/std/prelude/index.html">標準ライブラリの prelude</a> モジュールには、
すべてのモジュールにインポートされるものが余すことなく定義されています。
そこには、<code>Option</code>, <code>Vec</code>, <code>drop</code>, <code>Clone</code> などの、頻繁に使われるアイテムが含まれます。</p>
<!--
The Rust compiler prioritizes any manually imported items over those
from the prelude, to make sure additions to the prelude will not break any existing code.
For example, if you have a crate or module called `example` containing a `pub struct Option;`,
then `use example::*;` will make `Option` unambiguously refer to the one from `example`;
not the one from the standard library.
-->
<p>Rust コンパイラは、手動で<!-- TODO: 明示的に、のほうがいいか？-->インポートされたアイテムをプレリュードからのものより優先します。
これにより、プレリュードに追加があっても既存のコードは壊れないようになっています。
たとえば、 <code>example</code> という名前のクレートまたはモジュールに <code>pub struct Option;</code> が含まれていたら、
<code>use example::*;</code> とすることで <code>Option</code> は曖昧性なく <code>example</code> に含まれるものを指し示し、
標準ライブラリのものは指しません。</p>
<!--
However, adding a _trait_ to the prelude can break existing code in a subtle way.
For example, a call to `x.try_into()` which comes from a `MyTryInto` trait might fail 
to compile if `std`'s `TryInto` is also imported, because the call to `try_into` is now 
ambiguous and could come from either trait. This is the reason we haven't added `TryInto` 
to the prelude yet, since there is a lot of code that would break this way.
-->
<p>ところが、<em>トレイト</em><!-- -->をプレリュードに追加すると、捉えがたい形でコードが壊れることがあります。
たとえば、<code>MyTryInto</code> トレイトで定義されている <code>x.try_into()</code> という呼び出しは、
<code>std</code> の <code>TryInto</code> もインポートされているときは、動かなくなる場合があります。
なぜなら、<code>try_into</code> の呼び出しは今や曖昧で、どちらのトレイトから来ているかわからないからです。
だからこそ我々は、 <code>TryInto</code> を未だにプレリュードに追加していませんでした。
追加してしまうと、多くのコードでそのような問題が起こりうるからです。</p>
<!--
As a solution, Rust 2021 will use a new prelude.
It's identical to the current one, except for three new additions:
-->
<p>解決策として、Rust 2021 では新たなプレリュードが使用されます。
変更点は、以下の3つが追加されたということだけです。</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html"><code>std::convert::TryInto</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html"><code>std::convert::TryFrom</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html"><code>std::iter::FromIterator</code></a></li>
</ul>
<!--
The tracking issue [can be found here](https://github.com/rust-lang/rust/issues/85684).
-->
<p>追跡用の Issue は<a href="https://github.com/rust-lang/rust/issues/85684">こちら</a>です。</p>
<!--
## Migration 
-->
<h2 id="移行"><a class="header" href="#移行">移行</a></h2>
<!--
As a part of the 2021 edition a migration lint, `rust_2021_prelude_collisions`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.
-->
<p>Rust 2018 コードベースから Rust 2021 への自動移行の支援のため、2021 エディションには、移行用のリント<code>rust_2021_prelude_collisions</code> が追加されています。</p>
<!--
In order to have `rustfix` migrate your code to be Rust 2021 Edition compatible, run:
-->
<p><code>rustfix</code> でコードを Rust 2021 エディションに適合させるためには、次のように実行します。</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<!--
The lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.
-->
<p>このリントは、新しくプレリュードに追加されたトレイトで定義されているメソッドと同名の関数やメソッドが呼び出されていることを検知します。
場合によっては、今までと同じ関数が呼び出されるように、あなたのコードを様々な方法で書き換えることもあります。</p>
<!--
If you'd like to migrate your code manually or better understand what `rustfix` is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.
-->
<p>コードの移行を手作業で行いたい方や <code>rustfix</code> が何を行うかをより詳しく理解したい方のために、どのような状況で移行が必要なのか、逆にどうであれば不要なのを以下に例示していきます。</p>
<!--
### Migration needed
-->
<h3 id="移行が必要な場合"><a class="header" href="#移行が必要な場合">移行が必要な場合</a></h3>
<!--
#### Conflicting trait methods
-->
<h4 id="トレイトメソッドの衝突"><a class="header" href="#トレイトメソッドの衝突">トレイトメソッドの衝突</a></h4>
<!--
When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:
-->
<p>あるスコープに、同じメソッド名を持つ2つのトレイトがある場合、どちらのメソッドが使用されるべきかは曖昧です。例えば：</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait&lt;A&gt; {
  // This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  
  // この関数名は、`std` の `FromIterator` トレイトの `from_iter` メソッドと同名。
  fn from_iter(x: Option&lt;A&gt;);
}

impl&lt;T&gt; MyTrait&lt;()&gt; for Vec&lt;T&gt; {
  fn from_iter(_: Option&lt;()&gt;) {}
}

fn main() {
  // Vec&lt;T&gt; implements both `std::iter::FromIterator` and `MyTrait` 
  // If both traits are in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `from_iter` method to call
  // Vec&lt;T&gt; は `std::iter::FromIterator` と `MyTrait` の両方を実装する
  // もし両方のトレイトがスコープに含まれる場合 (Rust 2021 ではそうであるが)、
  // どちらの `from_iter` メソッドを呼び出せばいいかが曖昧になる
  &lt;Vec&lt;i32&gt;&gt;::from_iter(None);
}
</code></pre></pre>
<!--
We can fix this by using fully qualified syntax:
-->
<p>完全修飾構文を使うと、これを修正できます:</p>
<pre><code class="language-rust ignore">fn main() {
  // Now it is clear which trait method we're referring to
  // こうすれば、どちらのトレイトメソッドを指し示しているかが明確になる
  &lt;Vec&lt;i32&gt; as MyTrait&lt;()&gt;&gt;::from_iter(None);
}
</code></pre>
<!--
#### Inherent methods on `dyn Trait` objects
-->
<h4 id="dyn-trait-オブジェクトの固有メソッド"><a class="header" href="#dyn-trait-オブジェクトの固有メソッド"><code>dyn Trait</code> オブジェクトの固有メソッド</a></h4>
<!--
Some users invoke methods on a `dyn Trait` value where the method name overlaps with a new prelude trait:
-->
<p><code>dyn Trait</code> の値に対してメソッドを呼び出すときに、メソッド名が新しくプレリュードに追加されたトレイトと重複していることがあります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod submodule {
  pub trait MyTrait {
    // This has the same name as `TryInto::try_into`
    fn try_into(&amp;self) -&gt; Result&lt;u32, ()&gt;;
  }
}

// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`
// `MyTrait` はここではスコープ内になく、パス付きで `submodule::MyTrait` としか利用できない
fn bar(f: Box&lt;dyn submodule::MyTrait&gt;) {
  // If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `try_into` method to call
  // `std::convert::TryInto` がスコープ内にあるときは (Rust 2021 ではそうなのだが)、
  // どちらの `try_into` メソッドを呼び出せばいいかが曖昧になる
  f.try_into();
}
<span class="boring">}
</span></code></pre></pre>
<!--
Unlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works 
as long as there is no trait in scope with a conflicting method name. When the `TryInto` trait is in scope (which is the case in Rust 2021),
this causes an ambiguity. Should the call be to `MyTrait::try_into` or `std::convert::TryInto::try_into`?
-->
<p>静的ディスパッチのときと違って、トレイトオブジェクトに対してトレイトメソッドを呼び出すときは、そのトレイトがスコープ内にある必要はありません。
<code>TryInto</code> トレイトがスコープ内にあるときは (Rust 2021 ではそうなのですが)、曖昧性が発生します。
<code>MyTrait::try_into</code> と <code>std::convert::TryInto::try_into</code> のどちらが呼び出されるべきなのでしょうか？</p>
<!--
In these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that 
the `dyn Trait` method is chosen, versus the methods from the prelude trait. For example, turning `f.try_into()` above into `(&*f).try_into()` 
ensures that we're calling `try_into` on the `dyn MyTrait` which can only refer to the `MyTrait::try_into` method.
-->
<p>この場合、さらなる参照外しをするか、もしくはメソッドレシーバーの型を明示することで修正できます。
これにより、<code>dyn Trait</code> のメソッドとプレリュードのトレイトのメソッドのどちらが選ばれているかが明確になります。
たとえば、上の <code>f.try_into()</code> を <code>(&amp;*f).try_into()</code> にすると、<code>try_into</code> が <code>dyn Trait</code> に対して呼び出されることがはっきりします。
これに該当するのは<code>MyTrait::try_into</code>メソッドのみです。</p>
<!--
### No migration needed
-->
<h3 id="移行が不要な場合"><a class="header" href="#移行が不要な場合">移行が不要な場合</a></h3>
<!--
####  Inherent methods
-->
<h4 id="固有メソッド"><a class="header" href="#固有メソッド">固有メソッド</a></h4>
<!--
Many types define their own inherent methods with the same name as a trait method. For instance, below the struct `MyStruct` implements `from_iter` which shares the same name with the method from the trait `FromIterator` found in the standard library:
-->
<p>トレイトメソッドと同名の固有メソッドを定義しているような型もたくさんあります。
たとえば、以下では <code>MyStruct</code> が <code>from_iter</code> を実装していますが、
これは標準ライブラリの <code>FromIterator</code> トレイトのメソッドと同名です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter::IntoIterator;

struct MyStruct {
  data: Vec&lt;u32&gt;
}

impl MyStruct {
  // This has the same name as `std::iter::FromIterator::from_iter`
  // これは `std::iter::FromIterator::from_iter` と同名
  fn from_iter(iter: impl IntoIterator&lt;Item = u32&gt;) -&gt; Self {
    Self {
      data: iter.into_iter().collect()
    }
  }
}

impl std::iter::FromIterator&lt;u32&gt; for MyStruct {
    fn from_iter&lt;I: IntoIterator&lt;Item = u32&gt;&gt;(iter: I) -&gt; Self {
      Self {
        data: iter.into_iter().collect()
      }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Inherent methods always take precedent over trait methods so there's no need for any migration.
-->
<p>固有メソッドは常にトレイトメソッドより優先されるため、移行作業の必要はありません。</p>
<!--
### Implementation Reference
-->
<h3 id="実装の参考事項"><a class="header" href="#実装の参考事項">実装の参考事項</a></h3>
<!--
The lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:
-->
<p>2021 エディションを導入することで名前解決に衝突が生じるかどうか（すなわち、エディションを変えることでコードが壊れるかどうか）を判断するために、このリントはいくつかの要素を考慮する必要があります。たとえば以下のような点です:</p>
<!--
- Is the call a [fully-qualified call] or does it use [dot-call method syntax]?
  - This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. `<Type as Trait>::method`)
- Is this an [inherent method] or [a trait method]?
  - Inherent methods that take `self` will take priority over `TryInto::try_into` as inherent methods take priority over trait methods, but inherent methods that take `&self` or `&mut self` won't take priority due to requiring a auto-reference (while `TryInto::try_into` does not, as it takes `self`)
- Is the origin of this method from `core`/`std`? (As the traits can't have a collision with themselves)
- Does the given type implement the trait it could have a collision against?
- Is the method being called via dynamic dispatch? (i.e. is the `self` type `dyn Trait`)
  - If so, trait imports don't affect resolution, and no migration lint needs to occur
-->
<ul>
<li><a href="https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls">完全修飾呼び出し</a>と<a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">ドット呼び出しメソッド構文</a>のどちらが使われているか？
<ul>
<li>これは、メソッド呼び出し構文の自動参照付けと自動参照外しによる名前の解決方法に影響します。ドット呼び出しメソッド構文では、手動で参照外し/参照付けすることで優先順位を決められますが、完全修飾呼び出しではメソッドパス中に型とトレイト名が指定されていなければなりません (例: <code>&lt;Type as Trait&gt;::method</code>)</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations">固有メソッド</a>と<a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations">トレイトメソッド</a>のどちらが呼び出されているか？
<ul>
<li>固有メソッドはトレイトメソッドより優先されるので、<code>self</code> を取るトレイトメソッドは、<code>TryInto::try_into</code>より優先されますが、<code>&amp;self</code> や <code>&amp;mut self</code> をとる固有メソッドは、自動参照付けが必要なので優先されません（もっとも、<code>TryInto</code> は <code>self</code> を取るので、それは当てはまりませんが）</li>
</ul>
</li>
<li>そのメソッドは <code>core</code> か <code>std</code> から来たものか？　（トレイトは自分自身とは衝突しないので）</li>
<li>その型は、名前が衝突するようなトレイトを実装しているか？</li>
<li>メソッドが動的ディスパッチによって呼び出されているか？  （つまり、 <code>self</code> の型が <code>dyn Trait</code> か？）
<ul>
<li>その場合、トレイトのインポートは名前解決に影響しないので、移行リントを出す必要はありません</li>
</ul>
</li>
</ul>
<!--
[fully-qualified call]: https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls
[dot-call method syntax]: https://doc.rust-lang.org/reference/expressions/method-call-expr.html
[inherent method]: https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations
[a trait method]: https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Default Cargo feature resolver
-->
<h1 id="デフォルトの-cargo-のフィーチャリゾルバ"><a class="header" href="#デフォルトの-cargo-のフィーチャリゾルバ">デフォルトの Cargo のフィーチャリゾルバ</a></h1>
<!--
## Summary
-->
<h2 id="概要-2"><a class="header" href="#概要-2">概要</a></h2>
<!--
- `edition = "2021"` implies `resolver = "2"` in `Cargo.toml`.
-->
<ul>
<li><code>edition = &quot;2021&quot;</code> では <code>Cargo.toml</code> で <code>resolver = &quot;2&quot;</code> が設定されているとみなされます。</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-2"><a class="header" href="#詳細-2">詳細</a></h2>
<!--
Since Rust 1.51.0, Cargo has opt-in support for a [new feature resolver][4]
which can be activated with `resolver = "2"` in `Cargo.toml`.
-->
<p>Rust 1.51.0 から、Cargo には<a href="https://doc.rust-lang.org/cargo/reference/resolver.html#feature-resolver-version-2">新しいフィーチャリゾルバ</a>がオプトインできるようになっています。
これは、<code>Cargo.toml</code> で <code>resolver = &quot;2&quot;</code> と書くことで有効化できます。</p>
<!--
Starting in Rust 2021, this will be the default.
That is, writing `edition = "2021"` in `Cargo.toml` will imply `resolver = "2"`.
-->
<p>Rust 2021 から、これがデフォルトになりました。
つまり、 <code>Cargo.toml</code> に <code>edition = &quot;2021&quot;</code> と書けば、暗黙に <code>resolver = &quot;2&quot;</code> も設定されているとみなされます。</p>
<!--
The resolver is a global setting for a [workspace], and the setting is ignored in dependencies.
The setting is only honored for the top-level package of the workspace.
If you are using a [virtual workspace], you will still need to explicitly set the [`resolver` field]
in the `[workspace]` definition if you want to opt-in to the new resolver.
-->
<p>このリゾルバは<a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">ワークスペース</a>全体に設定され、依存先では無視されます。
また、この設定はワークスペースの最上位のパッケージでしか効きません。
<a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-manifest">仮想ワークスペース</a>において新しいリゾルバをオプトインしたい場合は、
以前と同様に <a href="https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions"><code>resolver</code> フィールド</a>を明示的に設定する必要があります。　</p>
<!--
The new feature resolver no longer merges all requested features for
crates that are depended on in multiple ways.
See [the announcement of Rust 1.51][5] for details.
-->
<p>新しいフィーチャリゾルバは、クレートへの依存に異なるフィーチャが設定されていてもそれらをマージしないようになりました。
詳細は <a href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver">the announcement of Rust 1.51</a> に記載されています。</p>
<!--
[4]: ../../cargo/reference/resolver.html#feature-resolver-version-2
[5]: https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver
[workspace]: ../../cargo/reference/workspaces.html
[virtual workspace]: ../../cargo/reference/workspaces.html#virtual-manifest
[`resolver` field]: ../../cargo/reference/resolver.html#resolver-versions
-->
<!--
## Migration
-->
<h2 id="移行-1"><a class="header" href="#移行-1">移行</a></h2>
<!--
There are no automated migration tools for updating for the new resolver.
For most projects, there are usually few or no changes as a result of updating.
-->
<p>新しいリゾルバに適合させるための自動化された移行ツールはありません。
ほとんどのプロジェクトでは、更新後に必要な変更はあっても微々たるものでしょう。</p>
<!--
When updating with `cargo fix --edition`, Cargo will display a report if the new resolver will build dependencies with different features.
It may look something like this:
-->
<p><code>cargo fix --edition</code> でのアップデート時に、Cargo は新しいリゾルバで依存先のフィーチャに変更があるかどうかを表示します。
たとえば、このように表示されます:</p>
<blockquote>
<p>note: Switching to Edition 2021 will enable the use of the version 2 feature resolver in Cargo.
This may cause some dependencies to be built with fewer features enabled than previously.
More information about the resolver changes may be found at <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html">https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html</a><br>
When building the following dependencies, the given features will no longer be used:</p>
<p><em>(訳)</em> 2021 エディションに切り替えると、Cargoのフィーチャリゾルバがバージョン 2 に切り替わります。
切り替え後、いくつかの依存先では有効化されるフィーチャが減少することがあります。
リゾルバの変更点については、 <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html">https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html</a> もご覧ください。<br>
以下の依存先をビルドするときに、以下のフィーチャが使われなくなります:</p>
<pre><code class="language-text">  bstr v0.2.16: default, lazy_static, regex-automata, unicode
  libz-sys v1.1.3 (as host dependency): libc
</code></pre>
</blockquote>
<!--
This lets you know that certain dependencies will no longer be built with the given features.
-->
<p>これにより、記載されたフィーチャがその依存先で使われずにビルドされるようになることがわかります。</p>
<!--
### Build failures
-->
<h3 id="ビルドの失敗"><a class="header" href="#ビルドの失敗">ビルドの失敗</a></h3>
<!--
There may be some circumstances where your project may not build correctly after the change.
If a dependency declaration in one package assumes that certain features are enabled in another, and those features are now disabled, it may fail to compile.
-->
<p>状況によっては、変更後にプロジェクトが正しくビルドされなくなることもあります。
あるパッケージの依存関係が、別のパッケージにおいて特定のフィーチャが有効されることを前提にしている場合、そのフィーチャが使われなくなることでコンパイルに失敗するかもしれません。</p>
<!--
For example, let's say we have a dependency like this:
-->
<p>たとえば、我々のパッケージにこんな依存関係があったとしましょう：</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
bstr = { version = &quot;0.2.16&quot;, default-features = false }
# ...
</code></pre>
<!--
And somewhere in our dependency tree, another package has this:
-->
<p>そして依存関係の中にはこんなパッケージもあるとしましょう:</p>
<pre><code class="language-toml"># Another package's Cargo.toml
# 別のパッケージの Cargo.toml

[build-dependencies]
bstr = &quot;0.2.16&quot;
</code></pre>
<!--
In our package, we've been using the [`words_with_breaks`](https://docs.rs/bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks) method from `bstr`, which requires `bstr`'s  "unicode" feature to be enabled.
This has historically worked because Cargo unified the features of `bstr` between the two packages.
However, after updating to Rust 2021, the new resolver will build `bstr` twice, once with the default features (as a build dependency), and once with no features (as our normal dependency).
Since `bstr` is now being built without the "unicode" feature, the `words_with_breaks` method doesn't exist, and the build will fail with an error that the method is missing.
-->
<p>我々のパッケージでは、今までは <code>bstr</code> の <a href="https://docs.rs/bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks"><code>words_with_breaks</code></a> 関数を使用していたとします。この関数は(本来<!--訳注: わかりにくかったので勝手に入れました-->) <code>bstr</code> の &quot;unicode&quot; フィーチャを有効化しないと使えないものです。
歴史的事情から、今まではこれでもうまくいきました。というのも、Cargo は2つのパッケージで使われている <code>bstr</code> のフィーチャを共通化していたからです。
しかしながら、Rust 2021 へのアップデート後、 <code>bstr</code> は1回目(ビルド依存関係として)はデフォルトのフィーチャで、2回目(我々のパッケージの通常の依存先として)はフィーチャなしで、合計2回ビルドされます。
今や <code>bstr</code> は &quot;unicode&quot; フィーチャなしでビルドされるので、 <code>words_with_breaks</code> メソッドは存在せず、メソッドがないというエラーが発生してビルドは失敗します。</p>
<!--
The solution here is to ensure that the dependency is declared with the features you are actually using.
For example:
-->
<p>ここでの解決策は、依存関係の宣言に我々が実際に使っているフィーチャを書くようにすることです。</p>
<pre><code class="language-toml">[dependencies]
bstr = { version = &quot;0.2.16&quot;, default-features = false, features = [&quot;unicode&quot;] }
</code></pre>
<!--
In some cases, this may be a problem with a third-party dependency that you don't have direct control over.
You can consider submitting a patch to that project to try to declare the correct set of features for the problematic dependency.
Alternatively, you can add features to any dependency from within your own `Cargo.toml` file.
For example, if the `bstr` example given above was declared in some third-party dependency, you can just copy the correct dependency declaration into your own project.
The features will be unified, as long as they match the unification rules of the new resolver. Those are:
-->
<p>ときには、あなたが直接いじることのできないサードパーティな依存先で問題が発生することもあります。
その場合は、問題が起こっている依存関係について、正しくフィーチャを指定するように、そのプロジェクトにパッチを送るのもよいでしょう。
あるいは、自身の <code>Cargo.toml</code> に記載する依存関係にフィーチャを追加することもできます。
新しいリゾルバには以下のような併合ルールがあり、その下でフィーチャは併合されます。すなわち、</p>
<!--
* Features enabled on platform-specific dependencies for targets not currently being built are ignored.
* Build-dependencies and proc-macros do not share features with normal dependencies.
* Dev-dependencies do not activate features unless building a target that needs them (like tests or examples).
-->
<ul>
<li>現在ビルドされていないターゲットに対するプラットフォーム特有の依存関係で有効化されているフィーチャは、無視されます。</li>
<li>build-dependencies と proc-macro では、通常の依存関係とは独立したフィーチャが使用されます。</li>
<li>dev-dependencies では、(tests や examples などの) ターゲットをビルドするときに必要でない限り、フィーチャは有効化されません。</li>
</ul>
<!--
A real-world example is using [`diesel`](https://crates.io/crates/diesel) and [`diesel_migrations`](https://crates.io/crates/diesel_migrations).
These packages provide database support, and the database is selected using a feature, like this:
-->
<p>実際の例としては、<a href="https://crates.io/crates/diesel"><code>diesel</code></a> と <a href="https://crates.io/crates/diesel_migrations"><code>diesel_migrations</code></a> を使用する場合が挙げられます。
これらのパッケージはデータベースへのサポートを提供しますが、データベースはフィーチャを用いて選択されます。たとえば、こんな感じです:</p>
<pre><code class="language-toml">[dependencies]
diesel = { version = &quot;1.4.7&quot;, features = [&quot;postgres&quot;] }
diesel_migrations = &quot;1.4.0&quot;
</code></pre>
<!--
The problem is that `diesel_migrations` has an internal proc-macro which itself depends on `diesel`, and the proc-macro assumes its own copy of `diesel` has the same features enabled as the rest of the dependency graph.
After updating to the new resolver, it fails to build because now there are two copies of `diesel`, and the one built for the proc-macro is missing the "postgres" feature.
-->
<p>ここで問題なのは、 <code>diesel_migrations</code> は内部に <code>diesel</code> に依存する手続き的マクロをもちます。
この手続き的マクロは、自身が使用する <code>diesel</code> で有効化されているフィーチャが、依存関係木の他の場所で有効化されているものと同じであると仮定します。
ところが、新しいリゾルバが使用されると、2つの <code>diesel</code> が使用され、そのうち手続き的マクロ用のものは &quot;postgres&quot; フィーチャなしでビルドされるために、ビルドに失敗します。</p>
<!--
A solution here is to add `diesel` as a build-dependency with the required features, for example:
-->
<p>ここでの解決策は、<code>diesel</code> をビルド時の依存として追加し、そこに必要なフィーチャを指定することです。例えば以下のようになります。</p>
<pre><code class="language-toml">[build-dependencies]
diesel = { version = &quot;1.4.7&quot;, features = [&quot;postgres&quot;] }
</code></pre>
<!--
This causes Cargo to add "postgres" as a feature for host dependencies (proc-macros and build-dependencies).
Now, the `diesel_migrations` proc-macro will get the "postgres" feature enabled, and it will build correctly.
-->
<p>これにより、 Cargo はホスト依存関係（proc-macro と build-dependencies）のフィーチャとして &quot;postgres&quot; を追加します。</p>
<blockquote>
<p>訳注：ホスト依存関係とは、コンパイラホスト（コンパイラを実行しているプラットフォーム）向けにビルド・実行される依存を指し、proc-macroクレートやbuild-dependencies配下の依存クレートが該当します。
一方、通常の依存関係はコンパイルターゲットのプラットフォーム向けにビルドされます。</p>
</blockquote>
<p>これで、 <code>diesel_migrations</code> の手続き的マクロは &quot;postgres&quot; フィーチャが有効化された状態で走り、正しくビルドされます。</p>
<!--
The 2.0 release of `diesel` (currently in development) does not have this problem as it has been restructured to not have this dependency requirement.
-->
<p>(現在開発中の) <code>diesel</code> のリリース 2.0 では、このような仮定なしに動くよう再設計されているため、このような問題は発生しません。</p>
<!--
### Exploring features
-->
<h3 id="フィーチャを探索する"><a class="header" href="#フィーチャを探索する">フィーチャを探索する</a></h3>
<!--
The [`cargo tree`] command has had substantial improvements to help with the migration to the new resolver.
`cargo tree` can be used to explore the dependency graph, and to see which features are being enabled, and importantly *why* they are being enabled.
-->
<p><a href="https://doc.rust-lang.org/cargo/commands/cargo-tree.html"><code>cargo tree</code></a> コマンドには、新しいリゾルバへの移行を補助する、素晴らしい新機能が含まれています。
<code>cargo tree</code> を使えば、依存関係木を探索して、どのフィーチャが有効化されているか、そしてなにより<em>なぜ</em>それが有効化されているのかが分かります。</p>
<!--
One option is to use the `--duplicates` flag (`-d` for short), which will tell you when a package is being built multiple times.
Taking the `bstr` example from earlier, we might see:
-->
<p>例えば、<code>--duplicates</code> (短縮形: <code>-d</code>) フラグを使用すると、同じパッケージが複数回ビルドされている場所がわかります。
さきほどの <code>bstr</code> を例に取れば、このような表示になるでしょう:</p>
<pre><code class="language-console">&gt; cargo tree -d
bstr v0.2.16
└── foo v0.1.0 (/MyProjects/foo)

bstr v0.2.16
[build-dependencies]
└── bar v0.1.0
    └── foo v0.1.0 (/MyProjects/foo)

</code></pre>
<!--
This output tells us that `bstr` is built twice, and shows the chain of dependencies that led to its inclusion in both cases.
-->
<p>この出力から、<code>bstr</code> が複数回ビルドされていることと、どの依存関係をたどると双方が現れるかが分かります。</p>
<!--
You can print which features each package is using with the `-f` flag, like this:
-->
<p><code>-f</code> フラグを使えば、それぞれのパッケージがどのフィーチャを使用しているかがわかります。こんな感じです:</p>
<pre><code class="language-console">cargo tree -f '{p} {f}'
</code></pre>
<!--
This tells Cargo to change the "format" of the output, where it will print both the package and the enabled features.
-->
<p>こうすると、Cargo は出力の「フォーマット」を変更して、パッケージと有効化されているフィーチャの双方を表示するようになります。</p>
<!--
You can also use the `-e` flag to tell it which "edges" to display.
For example, `cargo tree -e features` will show in-between each dependency which features are being added by each dependency.
This option becomes more useful with the `-i` flag which can be used to "invert" the tree.
This allows you to see how features *flow* into a given dependency.
For example, let's say the dependency graph is large, and we're not quite sure who is depending on `bstr`, the following command will show that:
-->
<p>さらに、<code>-e</code> フラグを使用してどの「辺」を表示してほしいか指定することもできます。
例えば、<code>cargo tree -e features</code> とすれば、各依存関係の間に、各依存関係がどのフィーチャを追加しているのかが表示されます。
<code>-i</code> フラグを使って木を「反転」させると、このオプションはより便利になります。
例えば、依存関係木があまりにも大きくて、何が <code>bstr</code> に依存してるのかよくわからなくても、次のコマンドを実行すればいいです:</p>
<pre><code class="language-console">&gt; cargo tree -e features -i bstr
bstr v0.2.16
├── bstr feature &quot;default&quot;
│   [build-dependencies]
│   └── bar v0.1.0
│       └── bar feature &quot;default&quot;
│           └── foo v0.1.0 (/MyProjects/foo)
├── bstr feature &quot;lazy_static&quot;
│   └── bstr feature &quot;unicode&quot;
│       └── bstr feature &quot;default&quot; (*)
├── bstr feature &quot;regex-automata&quot;
│   └── bstr feature &quot;unicode&quot; (*)
├── bstr feature &quot;std&quot;
│   └── bstr feature &quot;default&quot; (*)
└── bstr feature &quot;unicode&quot; (*)
</code></pre>
<!--
This snippet of output shows that the project `foo` depends on `bar` with the "default" feature.
Then, `bar` depends on `bstr` as a build-dependency with the "default" feature.
We can further see that `bstr`'s  "default" feature enables "unicode" (among other features).
-->
<p>この出力例からは、<code>foo</code> が <code>bar</code> に &quot;default&quot; フィーチャ付きで依存していることがわかり、
<code>bar</code> はビルド時の依存として <code>bstr</code> に &quot;default&quot; フィーチャ付きで依存していることもわかります。
さらに、<code>bstr</code> の &quot;default&quot; フィーチャによって &quot;unicode&quot; フィーチャ（と、他のフィーチャも）が有効になっていることもわかります。</p>
<!--
[`cargo tree`]: ../../cargo/commands/cargo-tree.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# IntoIterator for arrays
-->
<h1 id="配列に対する-intoiterator"><a class="header" href="#配列に対する-intoiterator">配列に対する IntoIterator</a></h1>
<!--
## Summary
-->
<h2 id="概要-3"><a class="header" href="#概要-3">概要</a></h2>
<!--
- Arrays implement `IntoIterator` in *all* editions.
- Calls to `IntoIterator::into_iter` are *hidden* in Rust 2015 and Rust 2018 when using method call syntax
  (i.e., `array.into_iter()`). So, `array.into_iter()` still resolves to `(&array).into_iter()` as it
  has before.
- `array.into_iter()` changes meaning to be the call to `IntoIterator::into_iter` in Rust 2021.
-->
<ul>
<li><em>すべての</em>エディションで、配列が <code>IntoIterator</code> を実装するようになります。</li>
<li>Rust 2015 と Rust 2018 では、メソッド呼び出し構文が使われても（つまり <code>array.into_iter()</code> と書いても）、
<code>IntoIterator::into_iter</code> は<em>隠されて</em>います。
これにより、<code>array.into_iter()</code> は従来どおり <code>(&amp;array).into_iter()</code> に解決されます。</li>
<li>Rust 2021 から、<code>array.into_iter()</code> が <code>IntoIterator::into_iter</code> を意味するように変更されます。</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-3"><a class="header" href="#詳細-3">詳細</a></h2>
<!--
Until Rust 1.53, only *references* to arrays implement `IntoIterator`.
This means you can iterate over `&[1, 2, 3]` and `&mut [1, 2, 3]`,
but not over `[1, 2, 3]` directly.
-->
<p>Rust 1.53 より前は、配列の<em>参照</em>だけが <code>IntoIterator</code> を実装していました。
すなわち、<code>&amp;[1, 2, 3]</code> と <code>&amp;mut [1, 2, 3]</code> に対しては列挙できる一方で、<code>[1, 2, 3]</code> に対して列挙することはできませんでした。</p>
<pre><code class="language-rust ignore">for &amp;e in &amp;[1, 2, 3] {} // Ok :)
                        // OK :)

for e in [1, 2, 3] {} // Error :(
                      // エラー :(
</code></pre>
<!--
This has been [a long-standing issue][25], but the solution is not as simple as it seems.
Just [adding the trait implementation][20] would break existing code.
`array.into_iter()` already compiles today because that implicitly calls
`(&array).into_iter()` due to [how method call syntax works][22].
Adding the trait implementation would change the meaning.
-->
<p>これは<a href="https://github.com/rust-lang/rust/issues/25725">古くからある Issue</a>ですが、見た目ほど解決は簡単ではありません。
<a href="https://github.com/rust-lang/rust/pull/65819">トレイト実装を追加する</a>だけでは、既存のコードが壊れてしまいます。
<a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator">メソッド呼び出し構文の仕組み</a>上、<code>array.into_iter()</code> は現状でも <code>(&amp;array).into_iter()</code> とみなされてコンパイルが通ります。
トレイト実装を追加すると、その意味が変わってしまうのです。</p>
<!--
Usually this type of breakage (adding a trait implementation) is categorized as 'minor' and acceptable.
But in this case there is too much code that would be broken by it.
-->
<p>多くのケースで、この手の互換性破壊（トレイト実装の追加）は「軽微」で許容可能とみなされてきました。
しかし、このケースではあまりにも多くのコードが壊れてしまうのです。</p>
<!--
It has been suggested many times to "only implement `IntoIterator` for arrays in Rust 2021".
However, this is simply not possible.
You can't have a trait implementation exist in one edition and not in another,
since editions can be mixed.
-->
<p>何度も提案されてきたのは、「Rust 2021 でのみ配列に <code>IntoIterator</code> を実装する」ことでした。
しかし、これは単に不可能なのです。
エディションは併用されうるので、あるエディションではトレイト実装が存在して、別のエディションでは存在しない、というわけにはいかないからです。</p>
<!--
Instead, the trait implementation was added in *all* editions (starting in Rust 1.53.0)
but with a small hack to avoid breakage until Rust 2021.
In Rust 2015 and 2018 code, the compiler will still resolve `array.into_iter()`
to `(&array).into_iter()` like before, as if the trait implementation does not exist.
This *only* applies to the `.into_iter()` method call syntax.
It does not affect any other syntax such as `for e in [1, 2, 3]`, `iter.zip([1, 2, 3])` or
`IntoIterator::into_iter([1, 2, 3])`.
Those will start to work in *all* editions.
-->
<p>代わりに、(Rust 1.53.0 から)トレイト実装は<em>すべての</em>エディションで追加されましたが、
Rust 2021 より前のコードが破壊されないようにちょっとしたハックが行われました。
Rust 2015 と 2018 のコードでは、コンパイラは従来どおり <code>array.into_iter()</code> を <code>(&amp;array).into_iter()</code> に解決し、あたかもトレイト実装が存在しないかのように振る舞います。
これは <code>.into_iter()</code> というメソッド呼び出し構文<em>だけ</em>に適用されます。
一方、このルールは <code>for e in [1, 2, 3]</code>, <code>iter.zip([1, 2, 3])</code>, <code>IntoIterator::into_iter([1, 2, 3])</code> といった他の構文には適用されず、
そのような書き方は<em>全ての</em>エディションで使えるようになります。</p>
<!--
While it's a shame that this required a small hack to avoid breakage,
this solution keeps the difference between the editions to an absolute minimum.
-->
<p>互換性破壊を防ぐためにちょっとしたハックが必要になったのは残念ですが、
これによりエディション間の違いが最小限になったのです。</p>
<!--
## Migration
-->
<h2 id="移行-2"><a class="header" href="#移行-2">移行</a></h2>
<!--
A lint, `array_into_iter`, gets triggered whenever there is some call to `into_iter()` that will change
meaning in Rust 2021. The `array_into_iter` lint has already been a warning by default on all editions 
since the 1.41 release (with several enhancements made in 1.55). If your code is already warning free, 
then it should already be ready to go for Rust 2021!
-->
<p><code>into_iter()</code> への呼び出しのうち、Rust 2021 で意味が変わるようなものに対しては、
<code>array_into_iter</code> というリントが発生します。
1.41 のリリース以降、<code>array_into_iter</code> リントはすでにデフォルトで警告として発出されています（1.55 ではさらにいくつかの機能追加が行われました）。
警告が今現在出ていないコードは、今すぐにでも Rust 2021 に進むことができます！</p>
<!--
You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:
-->
<p>コードを自動的に Rust 2021 エディションに適合するよう自動移行するか、既に適合するものであることを確認するためには、以下のように実行すればよいです:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<!--
Because the difference between editions is small, the migration to Rust 2021 is fairly straight-forward.
-->
<p>エディション間の違いが少ないので、Rust 2021 への移行も非常に簡単です。</p>
<!--
For method calls of `into_iter` on arrays, the elements being implemented will change from references to owned values.
-->
<p>配列に対する <code>into_iter</code> のメソッド呼び出しに関しては、(<!--訳注-->イテレータの)要素が参照でなく所有権を持った値となります。</p>
<!--
For example:
-->
<p>例えば：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let array = [1u8, 2, 3];
  for x in array.into_iter() {
    // x is a `&amp;u8` in Rust 2015 and Rust 2018
    // x is a `u8` in Rust 2021
    // Rust 2015 と Rust 2018 では、x は `&amp;u8`
    // Rust 2021 では、x は `u8`
  }
}
</code></pre></pre>
<!--
The most straightforward way to migrate in Rust 2021, is by keeping the exact behavior from previous editions
by calling `iter()` which also iterates over owned arrays by reference:
-->
<p>移行のための最も簡単な方法は、前のエディションと完全に同じ挙動をするように、
所有権を持った配列上を参照でイテレートするもう一つのメソッド <code>iter()</code> を呼び出すことです:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let array = [1u8, 2, 3];
  for x in array.iter() { // &lt;- This line changed
                          // &lt;- この行を書き換えた
    // x is a `&amp;u8` in all editions
    // x はすべてのエディションで `&amp;u8`
  }
}
</code></pre></pre>
<!--
### Optional migration
-->
<h3 id="必須でない移行"><a class="header" href="#必須でない移行">必須でない移行</a></h3>
<!--
If you are using fully qualified method syntax (i.e., `IntoIterator::into_iter(array)`) in a previous edition,
this can be upgraded to method call syntax (i.e., `array.into_iter()`).
-->
<p>前のエディションで完全修飾メソッド構文を使っていた場合（例: <code>IntoIterator::into_iter(array)</code>）、
これはメソッド呼び出し構文に書き換え可能です（例: <code>array.into_iter()</code>）。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Disjoint capture in closures
-->
<h1 id="クロージャはフィールドごとにキャプチャする"><a class="header" href="#クロージャはフィールドごとにキャプチャする">クロージャはフィールドごとにキャプチャする</a></h1>
<!--
## Summary
-->
<h2 id="概要-4"><a class="header" href="#概要-4">概要</a></h2>
<!--
- `|| a.x + 1` now captures only `a.x` instead of `a`.
- This can cause things to be dropped at different times or affect whether closures implement traits like `Send` or `Clone`.
  - If possible changes are detected, `cargo fix` will insert statements like `let _ = &a` to force a closure to capture the entire variable.
-->
<ul>
<li><code>|| a.x + 1</code> が <code>a</code> でなく <code>a.x</code> だけをキャプチャするようになりました。</li>
<li>これにより、ドロップのタイミングが変わったり、クロージャが <code>Send</code> や <code>Clone</code> を実装するかどうかが変わったりします。
<ul>
<li><code>cargo fix</code> は、このような違いが起こりうると検出した場合、 <code>let _ = &amp;a</code> のような文を挿入して、クロージャが変数全体をキャプチャするように強制します。</li>
</ul>
</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-4"><a class="header" href="#詳細-4">詳細</a></h2>
<!--
[Closures](https://doc.rust-lang.org/book/ch13-01-closures.html)
automatically capture anything that you refer to from within their body.
For example, `|| a + 1` automatically captures a reference to `a` from the surrounding context.
-->
<p><a href="https://doc.rust-jp.rs/book-ja/ch13-01-closures.html">クロージャ</a>は、本体の中で使用しているすべてのものを自動的にキャプチャします。
例えば、<code>|| a + 1</code> と書くと、周囲のコンテキスト中の <code>a</code> への参照が自動的にキャプチャされます。</p>
<!--
In Rust 2018 and before, closures capture entire variables, even if the closure only uses one field.
For example, `|| a.x + 1` captures a reference to `a` and not just `a.x`.
Capturing `a` in its entirety prevents mutation or moves from other fields of `a`, so that code like this does not compile:
-->
<p>Rust 2018 以前では、クロージャに使われているのが1つのフィールドだけであっても、クロージャは変数全体をキャプチャします。
例えば、 <code>|| a.x + 1</code> は <code>a.x</code> への参照だけでなく、<code>a</code> への参照をキャプチャします。
<code>a</code> 全体がキャプチャされると、<code>a</code> の他のフィールドの値を書き換えたりムーブしたりできなくなります。従って以下のようなコードはコンパイルに失敗します:</p>
<pre><code class="language-rust ignore">let a = SomeStruct::new();
drop(a.x); // Move out of one field of the struct
           // 構造体のフィールドの1つをムーブする
println!(&quot;{}&quot;, a.y); // Ok: Still use another field of the struct
                     // OK: 構造体の他のフィールドは、まだ使える
let c = || println!(&quot;{}&quot;, a.y); // Error: Tries to capture all of `a`
                                // エラー: `a` 全体をキャプチャしようとする
c();
</code></pre>
<!--
Starting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.
-->
<p>Rust 2021 からは、クロージャのキャプチャはより精密になります。 特に、使用されるフィールドだけがキャプチャされるようになります
（場合によっては、使用する変数以外にもキャプチャすることもあり得ます。詳細に関しては Rust リファレンスを参照してください）。
したがって、上記のコードは Rust 2021 では問題ありません。</p>
<!--
Disjoint capture was proposed as part of [RFC 2229](https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md) and the RFC contains details about the motivation.
-->
<p>フィールドごとのキャプチャは <a href="https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md">RFC 2229</a> の一部として提案されました。この RFC にはより詳しい動機が記載されています。</p>
<!--
## Migration
-->
<h2 id="移行-3"><a class="header" href="#移行-3">移行</a></h2>
<!--
As a part of the 2021 edition a migration lint, `rust_2021_incompatible_closure_captures`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.
-->
<p>Rust 2018 のコードベースから Rust 2021 への自動移行の支援のため、2021 エディションには、移行用のリント<code>rust_2021_incompatible_closure_captures</code> が追加されています。</p>
<!--
In order to have `rustfix` migrate your code to be Rust 2021 Edition compatible, run:
-->
<p><code>rustfix</code> でコードを Rust 2021 エディションに適合させるためには、次のように実行します。</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<!--
Below is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail 
or you would like to better understand how the migration works.
-->
<p>以下では、クロージャによるキャプチャが出現するコードについて、自動移行が失敗した場合に手動で Rust 2021 に適合するように移行するにはどうすればいいかを考察します。
移行がどのようになされるか知りたい人も以下をお読みください。</p>
<!--
Changing the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:
-->
<p>クロージャによってキャプチャされる変数が変わると、プログラムの挙動が変わったりコンパイルできなくなったりすることがありますが、その原因は以下の2つです:</p>
<!--
- changes to drop order, or when destructors run ([details](#drop-order));
- changes to which traits a closure implements ([details](#trait-implementations)).
-->
<ul>
<li>ドロップの順序や、デストラクタが走るタイミングが変わる場合（<a href="rust-2021/disjoint-capture-in-closures.html#%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%E3%81%AE%E9%A0%86%E5%BA%8F">詳細</a>）</li>
<li>クロージャが実装するトレイトが変わる場合（<a href="rust-2021/disjoint-capture-in-closures.html#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E5%AE%9F%E8%A3%85">詳細</a>）</li>
</ul>
<!--
Whenever any of the scenarios below are detected, `cargo fix` will insert a "dummy let" into your closure to force it to capture the entire variable:
-->
<p>以下のような状況を検知すると、<code>cargo fix</code> は「ダミーの let」をクロージャの中に挿入して、強制的に全ての変数がキャプチャされるようにします:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (vec![22], vec![23]);
let c = move || {
    // &quot;Dummy let&quot; that forces `x` to be captured in its entirety
    // `x` 全体が強制的にキャプチャされるための「ダミーの let」
    let _ = &amp;x;

    // Otherwise, only `x.0` would be captured here
    // それがないと、`x.0` だけがここでキャプチャされる
    println!(&quot;{:?}&quot;, x.0);
};
<span class="boring">}
</span></code></pre></pre>
<!--
This is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.
-->
<p>この解析は保守的です。ほとんどの場合、ダミーの let は問題なく消すことができ、消してもプログラムはきちんと動きます。</p>
<!--
### Wild Card Patterns
-->
<h3 id="ワイルドカードパターン"><a class="header" href="#ワイルドカードパターン">ワイルドカードパターン</a></h3>
<!--
Closures now only capture data that needs to be read, which means the following closures will not capture `x`:
-->
<p>クロージャは本当に読む必要のあるデータだけをキャプチャするようになったので、次のコードは <code>x</code> をキャプチャしません:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let c = || {
    let _ = x; // no-op
               // 何もしない
};

let c = || match x {
    _ =&gt; println!(&quot;Hello World!&quot;)
};
<span class="boring">}
</span></code></pre></pre>
<!--
The `let _ = x` statement here is a no-op, since the `_` pattern completely ignores the right-hand side, and `x` is a reference to a place in memory (in this case, a variable).
-->
<p>この <code>let _ = x</code> は何もしません。
なぜなら、<code>_</code> パターンは右辺を無視し、さらに、<code>x</code> はメモリ上のある場所（この場合は変数）への参照だからです。</p>
<!--
This change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the "drop order" change below.
-->
<p>この変更（いくつかの値がキャプチャされなくなること）そのものによってコード変更の提案がなされることはありませんが、後で説明する「ドロップ順序」の変更と組み合わせると、提案がなされる場合もあります。</p>
<!--
**Subtle:** There are other similar expressions, such as the "dummy lets" `let _ = &x` that we insert, which are not no-ops. This is because the right-hand side (`&x`) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).
-->
<p><strong>ちなみに:</strong> 似たような式の中には、同じく自動挿入される &quot;ダミーの let&quot; であっても、<code>let _ = &amp;x</code> のように「何もしない」わけではない文もあります。なぜかというと、右辺（<code>&amp;x</code>）はメモリ上のある場所を指し示すのではなく、値が評価されるべき式となるからです（その評価結果は捨てられますが）。</p>
<!--
### Drop Order
-->
<h3 id="ドロップの順序"><a class="header" href="#ドロップの順序">ドロップの順序</a></h3>
<!--
When a closure takes ownership of a value from a variable `t`, that value is then dropped when the closure is dropped, and not when the variable `t` goes out of scope:
-->
<p>クロージャが変数 <code>t</code> の値の所有権を取るとき、その値がドロップされるのは <code>t</code> がスコープ外に出たときではなく、そのクロージャがドロップされたときになります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>{
    let t = (vec![0], vec![0]);

    {
        let c = || move_value(t); // t is moved here
    } // c is dropped, which drops the tuple `t` as well
      // c がドロップされ、そのときにタプル `t` もまたドロップされる
} // t goes out of scope here
  // t はここでスコープを抜ける
<span class="boring">}
</span></code></pre></pre>
<!--
The above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of _part_ of a variable, there can be differences:
-->
<p>上記のコードの挙動は Rust 2018 と Rust 2021 で同じです。ところが、クロージャが変数の<!-- --><em>一部</em><!-- -->の所有権を取るとき、違いが発生します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>{
    let t = (vec![0], vec![0]);

    {
        let c = || {
            // In Rust 2018, captures all of `t`.
            // In Rust 2021, captures only `t.0`
            // Rust 2018 では、`t` 全体がキャプチャされる。
            // Rust 2018 では、`t.0` だけがキャプチャされる
            move_value(t.0);
        };

        // In Rust 2018, `c` (and `t`) are both dropped when we
        // exit this block.
        // Rust 2018 では、 `c` (と `t`) の両方が
        // このブロックを抜けるときにドロップされる。
        //
        // In Rust 2021, `c` and `t.0` are both dropped when we
        // exit this block.
        // Rust 2021 では、 `c` と `t.0` の両方が
        // このブロックを抜けるときにドロップされる。
    }

// In Rust 2018, the value from `t` has been moved and is
// not dropped.
// Rust 2018 では、`t` はすでにムーブされており、ここではドロップされない
//
// In Rust 2021, the value from `t.0` has been moved, but `t.1`
// remains, so it will be dropped here.
// Rust 2021 では、`t.0` はムーブされているが、
// `t.1` は残っており、ここでドロップされる
}
<span class="boring">}
</span></code></pre></pre>
<!--
In most cases, dropping values at different times just affects when memory is freed and is not important. However, some `Drop` impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy `let` to force the entire variable to be captured.
-->
<p>ほとんどの場合、ドロップのタイミングが変わってもメモリが解放されるタイミングが変わるだけで、さほど問題にはなりません。
しかし、<code>Drop</code> の実装に副作用のある（いわゆるデストラクタである）場合、ドロップの順序が変わるとプログラムの意味が変わってしまうかもしれません。
その場合は、コンパイラはダミーの <code>let</code> を挿入して変数全体がキャプチャされるように提案します。</p>
<!--
### Trait implementations
-->
<h3 id="トレイト実装"><a class="header" href="#トレイト実装">トレイト実装</a></h3>
<!--
Closures automatically implement the following traits based on what values they capture:
-->
<p>何がキャプチャされているかによって、クロージャには自動的に以下のトレイトが実装されます:</p>
<!--
- [`Clone`]: if all captured values are [`Clone`].
- [Auto traits] like [`Send`], [`Sync`], and [`UnwindSafe`]: if all captured values implement the given trait.
-->
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>: キャプチャされた値がすべて <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> を実装していた場合。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, <a href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html"><code>UnwindSafe</code></a> などの<a href="https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits">自動トレイト</a>: キャプチャされた値がすべてそのトレイトを実装していた場合。</li>
</ul>
<!--
[auto traits]: https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits
[`clone`]: https://doc.rust-lang.org/std/clone/trait.Clone.html
[`send`]: https://doc.rust-lang.org/std/marker/trait.Send.html
[`sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html
[`unwindsafe`]: https://doc.rust-lang.org/std/marker/trait.UnwindSafe.html
-->
<!--
In Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then "dummy lets" are inserted.
-->
<p>Rust 2021 では、キャプチャされる値が変わることによって、クロージャが実装するトレイトも変わることがあります。
先ほどの移行リントは、それぞれのクロージャについて、これまで実装されていた自動トレイトが何であるか、そして移行後もそれらが残るかどうかを調べます。
もし今まで実装されていたトレイトが実装されなくなる場合、「ダミーの let」が挿入されます。</p>
<!--
For instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement `Send`/`Sync` auto trait for the wrapper. The closure that is passed to `thread::spawn` uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is `Send`/`Sync`, the code is considered safe and therefore compiles successfully.
-->
<p>例えば、スレッド間で生ポインタを受け渡しする一般的な方法に、ポインタを構造体でラップし、そのラッパー構造体に自動トレイト <code>Send</code>/<code>Sync</code> を実装するというものがあります。
<code>thread::spawn</code> に渡されるクロージャが使うのは、ラッパー構造体のうち特定の変数だけですが、キャプチャされるのはラッパー構造体全体です。
ラッパー構造体は <code>Send</code>/<code>Sync</code> なので、コードは安全であるとみなされ、コンパイルは成功します。</p>
<!--
With disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally `Send`/`Sync` defeating the purpose of the wrapper.
-->
<p>フィールドごとのキャプチャが導入されると、キャプチャ内で使用されているフィールドだけがキャプチャされますが、フィールドの中身はもともと <code>Send</code>/<code>Sync</code> でなかったのですから、せっかくラッパーを作っても元の木阿弥です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

struct Ptr(*mut i32);
unsafe impl Send for Ptr {}


let mut x = 5;
let px = Ptr(&amp;mut x as *mut i32);

let c = thread::spawn(move || {
    unsafe {
        *(px.0) += 10;
    }
}); // Closure captured px.0 which is not Send
    // クロージャは px.0 をキャプチャしたが、これは Send ではない
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Panic macro consistency
-->
<h1 id="panic-マクロの一貫性"><a class="header" href="#panic-マクロの一貫性">panic マクロの一貫性</a></h1>
<!--
## Summary
-->
<h2 id="概要-5"><a class="header" href="#概要-5">概要</a></h2>
<!--
- `panic!(..)` now always uses `format_args!(..)`, just like `println!()`.
- `panic!("{")` is no longer accepted, without escaping the `{` as `{{`.
- `panic!(x)` is no longer accepted if `x` is not a string literal.
  - Use `std::panic::panic_any(x)` to panic with a non-string payload.
  - Or use `panic!("{}", x)` to use `x`'s `Display` implementation.
- The same applies to `assert!(expr, ..)`.
-->
<ul>
<li><code>panic!(..)</code> では常に <code>format_args!(..)</code> が使われるようになりました。つまり、<code>println!()</code> と同じ書き方をすることになります。</li>
<li><code>panic!(&quot;{&quot;)</code> と書くことはできなくなりました。<code>{</code> を <code>{{</code> とエスケープしなくてはなりません。</li>
<li><code>x</code> が文字列リテラルでないときに、 <code>panic!(x)</code> と書くことはできなくなりました。
<ul>
<li>文字列でないペイロード付きでパニックしたい場合、 <code>std::panic::panic_any(x)</code> を使うようにしてください。</li>
<li>もしくは、<code>x</code> の <code>Display</code> 実装を用いて、<code>panic!(&quot;{}&quot;, x)</code> と書いてください。</li>
</ul>
</li>
<li><code>assert!(expr, ..)</code> に関しても同様です。</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-5"><a class="header" href="#詳細-5">詳細</a></h2>
<!--
The `panic!()` macro is one of Rust's most well known macros.
However, it has [some subtle surprises](https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md)
that we can't just change due to backwards compatibility.
-->
<p><code>panic!()</code> は、Rust で最もよく知られたマクロの一つです。
しかし、このマクロには<a href="https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md">いくぶん非直感的な挙動</a>がありましたが、
今までは後方互換性の問題から修正できませんでした。</p>
<pre><code class="language-rust ignore">// Rust 2018
panic!(&quot;{}&quot;, 1); // Ok, panics with the message &quot;1&quot;
                 // OK。 &quot;1&quot; というメッセージと共にパニックする
panic!(&quot;{}&quot;); // Ok, panics with the message &quot;{}&quot;
              // OK。 &quot;{}&quot; というメッセージと共にパニックする
</code></pre>
<!--
The `panic!()` macro only uses string formatting when it's invoked with more than one argument.
When invoked with a single argument, it doesn't even look at that argument.
-->
<p><code>panic!()</code> マクロは、2つ以上の引数が渡されたときだけ、フォーマット文字列を使用します。
引数が1つのときは、引数の中身に見向きもしません。</p>
<pre><code class="language-rust ignore">// Rust 2018
let a = &quot;{&quot;;
println!(a); // Error: First argument must be a format string literal
             // エラー: 第一引数は文字列リテラルでなくてはならない
panic!(a); // Ok: The panic macro doesn't care
           // OK: panicマクロは気にしない
</code></pre>
<!--
It even accepts non-strings such as `panic!(123)`, which is uncommon and rarely useful since it
produces a surprisingly unhelpful message: `panicked at 'Box<Any>'`.
-->
<p>その上、このマクロは <code>panic!(123)</code> のように文字列でない引数を渡すこともできました。
このような使い方は稀で、ほとんど役に立ちません。
というのも、この呼び出しで出力されるメッセージはあきれるほど役に立たないからです: <code>panicked at 'Box&lt;Any&gt;'</code> (訳: <code>'Box&lt;Any&gt;</code> でパニックしました)。</p>
<!--
This will especially be a problem once
[implicit format arguments](https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html)
are stabilized.
That feature will make `println!("hello {name}")` a short-hand for `println!("hello {}", name)`.
However, `panic!("hello {name}")` would not work as expected,
since `panic!()` doesn't process a single argument as format string.
-->
<p>これで特に困るのは、<a href="https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html">暗黙のフォーマット引数</a>が安定化されたときです。
この機能により、<code>println!(&quot;hello {}&quot;, name)</code> の代わりに <code>println!(&quot;hello {name}&quot;)</code> と略記できるようになります。
しかし、<code>panic!(&quot;hello {name}&quot;)</code> は期待される挙動を示しません。
なぜなら、<code>panic!()</code> は引数が1つだけ与えられたときにそれをフォーマット文字列として扱わないからです。</p>
<!--
To avoid that confusing situation, Rust 2021 features a more consistent `panic!()` macro.
The new `panic!()` macro will no longer accept arbitrary expressions as the only argument.
It will, just like `println!()`, always process the first argument as format string.
Since `panic!()` will no longer accept arbitrary payloads,
[`panic_any()`](https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html)
will be the only way to panic with something other than a formatted string.
-->
<p>この紛らわしい状況を解決するために、Rust 2021 の <code>panic!()</code> マクロはより一貫したものになりました。
新しい <code>panic!()</code> マクロは、単一引数として任意の式を受け付けることがなくなりました。
代わりに、<code>println!()</code> と同様に、常に最初の引数をフォーマット文字列として処理するようになりました。
<code>panic!()</code> マクロが任意のペイロードを受け付けるわけではなくなったので、
フォーマット文字列以外のペイロードと共にパニックさせる唯一の方法は、
<a href="https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html"><code>panic_any()</code></a>を使うことだけになりました。</p>
<pre><code class="language-rust ignore">// Rust 2021
panic!(&quot;{}&quot;, 1); // Ok, panics with the message &quot;1&quot;
                 // Ok。&quot;1&quot; というメッセージと共にパニックする
panic!(&quot;{}&quot;); // Error, missing argument
              // エラー。引数が足りない
panic!(a); // Error, must be a string literal
           // エラー。文字列リテラルでないといけない
</code></pre>
<!--
In addition, `core::panic!()` and `std::panic!()` will be identical in Rust 2021.
Currently, there are some historical differences between those two,
which can be noticeable when switching `#![no_std]` on or off.
-->
<p>さらに、<code>core::panic!()</code> と <code>std::panic!()</code> は Rust 2021 で同一のものになります。
現在は、これらの間には歴史的な違いがあり、
<code>#![no_std]</code> のオンオフを切り替えることで見て取ることができます。</p>
<!--
## Migration
-->
<h2 id="移行-4"><a class="header" href="#移行-4">移行</a></h2>
<!--
A lint, `non_fmt_panics`, gets triggered whenever there is some call to `panic` that uses some 
deprecated behavior that will error in Rust 2021. The `non_fmt_panics` lint has already been a warning 
by default on all editions since the 1.50 release (with several enhancements made in later releases). 
If your code is already warning free, then it should already be ready to go for Rust 2021!
-->
<p><code>panic</code> への呼び出しのうち、非推奨の挙動を使用していて Rust 2021 ではエラーになる場所に対して、<code>non_fmt_panics</code> というリントが発生します。
Rust 1.50 以降、<code>non_fmt_panics</code> リントはすでにデフォルトで警告として発出されています（後のバージョンではさらにいくつかの機能追加が行われました）。
警告が今現在出ていないコードは、今すぐにでも Rust 2021 に進むことができます！</p>
<!--
You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:
-->
<p>コードを自動的に Rust 2021 エディションに適合するよう自動移行するか、既に適合するものであることを確認するためには、以下のように実行すればよいです:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<!--
Should you choose or need to manually migrate, you'll need to update all panic invocations to either use the same 
formatting as `println` or use `std::panic::panic_any` to panic with non-string data.
-->
<p>手動で移行することを選んだり、そうする必要がある場合には、各 panic の呼び出しについて、 <code>println</code> と同様のフォーマットに書き換えるか、<code>std::panic::panic_any</code> を用いて非文字列型のデータと共にパニックさせるかを選ぶ必要があります。</p>
<!--
For example, in the case of `panic!(MyStruct)`, you'll need to convert to using `std::panic::panic_any` (note
that this is a function not a macro): `std::panic::panic_any(MyStruct)`.
-->
<p>例えば、<code>panic!(MyStruct)</code> の場合、<code>std::panic::panic_any</code> （これはマクロでなく関数であることに注意）を使うよう書き換えて、<code>std::panic::panic_any(MyStruct)</code> とすればよいです。</p>
<!--
In the case of panic messages that include curly braces but the wrong number of arguments (e.g., `panic!("Some curlies: {}")`), 
you can panic with the string literal by either using the same syntax as `println!` (i.e., `panic!("{}", "Some curlies: {}")`) 
or by escaping the curly braces (i.e., `panic!("Some curlies: {{}}")`).
-->
<p>パニックのメッセージに波括弧が含まれているのに、引数の個数が一致しない場合は（例: <code>panic!(&quot;Some curlies: {}&quot;)</code>）、
<code>println!</code> と同じ構文を使うか（つまり <code>panic!(&quot;{}&quot;, &quot;Some curlies: {}&quot;)</code> とするか）、波括弧をエスケープすれば（つまり <code>panic!(&quot;Some curlies: {{}}&quot;)</code> とすれば）、
その文字列リテラルを用いてパニックすることができます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Reserving syntax
-->
<h1 id="構文の予約"><a class="header" href="#構文の予約">構文の予約</a></h1>
<!--
## Summary
-->
<h2 id="概要-6"><a class="header" href="#概要-6">概要</a></h2>
<!--
- `any_identifier#`, `any_identifier"..."`, and `any_identifier'...'` are now reserved
  syntax, and no longer tokenize.
- This is mostly relevant to macros. E.g. `quote!{ #a#b }` is no longer accepted.
- It doesn't treat keywords specially, so e.g. `match"..." {}` is no longer accepted.
- Insert whitespace between the identifier and the subsequent `#`, `"`, or `'`
  to avoid errors.
- Edition migrations will help you insert whitespace in such cases.
-->
<ul>
<li><code>shikibetsushi#</code>, <code>shikibetsushi&quot;...&quot;</code>, <code>shikibetsushi'...'</code> の3つの構文が新たに予約され、トークン分割されなくなりました。</li>
<li>主に影響を受けるのはマクロです。例えば、<code>quote!{ #a#b }</code> と書くことはできなくなりました。</li>
<li>キーワードが特別扱いされることもないので、例えば <code>match&quot;...&quot; {}</code> と書くこともできなくなりました。</li>
<li>識別子と後続の <code>#</code>, <code>&quot;</code>, <code>'</code> の間に空白文字を挿入することで、エラーを回避できます。</li>
<li>エディション移行ツールは、必要な場所に空白を挿入してくれます。</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-6"><a class="header" href="#詳細-6">詳細</a></h2>
<!--
To make space for new syntax in the future,
we've decided to reserve syntax for prefixed identifiers and literals:
`prefix#identifier`, `prefix"string"`, `prefix'c'`, and `prefix#123`,
where `prefix` can be any identifier.
(Except those prefixes that already have a meaning, such as `b'...'` (byte
strings) and `r"..."` (raw strings).)
-->
<p>私達は、将来新しい構文を導入する余地を残すため、接頭辞付きの識別子とリテラルの構文を予約することにしました。
予約されたのは、任意の識別子 <code>prefix</code> を用いて <code>prefix#identifier</code>, <code>prefix&quot;string&quot;</code>, <code>prefix'c'</code>, <code>prefix#123</code> のいずれかの形で書かれるものです。
(ただし、<code>b'...'</code>（バイト文字列）や<code>r&quot;...&quot;</code>（生文字列）のように、すでに意味が割り当てられているものを除きます。）</p>
<!--
This provides syntax we can expand into in the future without requiring an
edition boundary. We may use this for temporary syntax until the next edition,
or for permanent syntax if appropriate.
-->
<p>これにより、将来エディションをまたくごとなく構文を拡張できるようになります。
これを、次のエディションまでの一時的な構文のために使ったり、もし適切なら、恒久的な構文のために使ったりするでしょう。</p>
<!--
Without an edition, this would be a breaking change, since macros can currently
accept syntax such as `hello"world"`, which they will see as two separate
tokens: `hello` and `"world"`. The (automatic) fix is simple though: just
insert a space: `hello "world"`. Likewise, `prefix#ident` should become
`prefix #ident`. Edition migrations will help with this fix.
-->
<p>エディションの区切りがないと、これは破壊的変更に当たります。
なぜなら、現在のマクロは、例えば <code>hello&quot;world&quot;</code> という構文を、 <code>hello</code> と <code>&quot;world&quot;</code> の2つのトークンとして受け入れるからです。
もっとも、（自動）修正はシンプルで、<code>hello &quot;world&quot;</code> のように空白を入れるだけです。
同様に、<code>prefix#ident</code> は <code>prefix #ident</code> とする必要があります。
エディション移行ツールは、そのように修正してくれます。</p>
<!--
Other than turning these into a tokenization error,
[the RFC][10] does not attach a meaning to any prefix yet.
Assigning meaning to specific prefixes is left to future proposals,
which will now&mdash;thanks to reserving these prefixes&mdash;not be breaking changes.
-->
<p><a href="https://github.com/rust-lang/rfcs/pull/3101">これが提案された RFC</a> は、このような書き方をトークン分割エラーにすると決めているだけで、
特定の接頭辞に意味を持たせることはまだしていません。
接頭辞に何らかの役割を割り当てるのは、将来の提案にその余地が残されています。
接頭辞が予約されたおかげで、今後は破壊的変更なく新しい構文を導入できます。</p>
<!--
Some new prefixes you might potentially see in the future (though we haven't
committed to any of them yet):
-->
<p>例えば、以下のような接頭辞が使えるようになるかもしれません（ただし、いずれもまだ提案が固まったわけではありません）:</p>
<!--
- `k#keyword` to allow writing keywords that don't exist yet in the current edition.
  For example, while `async` is not a keyword in edition 2015,
  this prefix would've allowed us to accept `k#async` in edition 2015
  without having to wait for edition 2018 to reserve `async` as a keyword.
-->
<ul>
<li><code>k#keyword</code> で、現在のエディションにまだ導入されていないキーワードを書けるようにする。
たとえば、2015 エディションでは <code>async</code> はキーワードではありませんが、
このような接頭辞が使えたのならば、2018 エディションで <code>async</code> が予約語になるのを待たずに、2015 エディションでも <code>k#async</code> が使えたということになります。</li>
</ul>
<!--
- `f""` as a short-hand for a format string.
  For example, `f"hello {name}"` as a short-hand for the equivalent `format!()` invocation.
-->
<ul>
<li><code>f&quot;&quot;</code> で、フォーマット文字列の略記とする。
例えば、<code>f&quot;hello {name}&quot;</code> と書いたら、それと等価な <code>format!()</code> の呼び出しと見なす。</li>
</ul>
<!--
- `s""` for `String` literals.
-->
<ul>
<li><code>s&quot;&quot;</code> で <code>String</code> リテラルを表す。</li>
</ul>
<!--
- `c""` or `z""` for null-terminated C strings.
-->
<ul>
<li><code>c&quot;&quot;</code> か <code>z&quot;&quot;</code> で、ヌル終端のC言語の文字列を表す。</li>
</ul>
<!--
## Migration 
-->
<h2 id="移行-5"><a class="header" href="#移行-5">移行</a></h2>
<!--
As a part of the 2021 edition a migration lint, `rust_2021_prefixes_incompatible_syntax`, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.
-->
<p>Rust 2018 のコードベースから Rust 2021 への自動移行の支援のため、2021 エディションには、移行用のリント<code>rust_2021_prefixes_incompatible_syntax</code> が追加されています。</p>
<!--
In order to have `rustfix` migrate your code to be Rust 2021 Edition compatible, run:
-->
<p><code>rustfix</code> でコードを Rust 2021 エディションに適合させるためには、次のように実行します。</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<!--
Should you want or need to manually migrate your code, migration is fairly straight-forward.
-->
<p>コード移行を手で行いたいか、行う必要があっても、移行は非常に簡単です。</p>
<!--
Let's say you have a macro that is defined like so:
-->
<p>例えば、次のように定義されたマクロがあったとしましょう：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro {
    ($a:tt $b:tt) =&gt; {};
}
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the first token tree and the second:
-->
<p>Rust 2015 と 2018 では、以下のように、1つ目と2つ目のトークンの間に空白を入れることなくマクロを呼び出しても問題ありませんでした:</p>
<pre><code class="language-rust ignore">my_macro!(z&quot;hey&quot;);
</code></pre>
<!--
This `z` prefix is no longer allowed in Rust 2021, so in order to call this macro, you must add a space after the prefix like so:
-->
<p>Rust 2021 では <code>z</code> という接頭辞は許されないので、このマクロを呼び出すためには、以下のように接頭辞の後にスペースを入れる必要があります:</p>
<pre><code class="language-rust ignore">my_macro!(z &quot;hey&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Warnings promoted to errors
-->
<h1 id="警告からエラーへの格上げ"><a class="header" href="#警告からエラーへの格上げ">警告からエラーへの格上げ</a></h1>
<!--
## Summary
-->
<h2 id="概要-7"><a class="header" href="#概要-7">概要</a></h2>
<!--
- Code that triggered the `bare_trait_objects` and `ellipsis_inclusive_range_patterns` lints will error in Rust 2021.
-->
<ul>
<li><code>bare_trait_objects</code> リントか <code>ellipsis_inclusive_range_patterns</code> リントが出るコードは、Rust 2021 ではエラーになります。</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-7"><a class="header" href="#詳細-7">詳細</a></h2>
<!--
Two existing lints are becoming hard errors in Rust 2021, but these lints will remain warnings in older editions.
-->
<p>現存する2つのリントが Rust 2021 ではエラーになります。古いエディションではこれらは警告のままです。</p>
<h3 id="bare_trait_objects"><a class="header" href="#bare_trait_objects"><code>bare_trait_objects</code>:</a></h3>
<!--
The use of the `dyn` keyword to identify [trait objects](https://doc.rust-lang.org/book/ch17-02-trait-objects.html)
will be mandatory in Rust 2021.
-->
<p>Rust 2021 では、<a href="https://doc.rust-jp.rs/book-ja/ch17-02-trait-objects.html">トレイトオブジェクト</a>を表すために、<code>dyn</code> キーワードを使用することが必須になりました。</p>
<!--
For example, the following code which does not include the `dyn` keyword in `&MyTrait`
will produce an error instead of just a lint in Rust 2021:
-->
<p>例えば、以下のコードでは <code>&amp;MyTrait</code> に <code>dyn</code> キーワードが含まれていないため、Rust 2021 ではただのリントではなくエラーが発生します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {}

pub fn my_function(_trait_object: &amp;MyTrait) { // should be `&amp;dyn MyTrait`
                                              // `&amp;dyn MyTrait` と書かなくてはならない
  unimplemented!()
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="ellipsis_inclusive_range_patterns"><a class="header" href="#ellipsis_inclusive_range_patterns"><code>ellipsis_inclusive_range_patterns</code>:</a></h3>
<!--
The [deprecated `...` syntax](https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns)
for inclusive range patterns (i.e., ranges where the end value is *included* in the range) is no longer 
accepted in Rust 2021. It has been superseded by `..=`, which is consistent with expressions.
-->
<p>閉区間パターン（つまり、終端の値を<em>含む</em>範囲）を表す、<a href="https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns">非推奨の <code>...</code> 構文</a>は、Rust 2021 では使えなくなります。
式との統一性のため、<code>..=</code> を使うことが推奨されていました。</p>
<!--
For example, the following code which uses `...` in a pattern will produce an error instead of 
just a lint in Rust 2021:
-->
<p>例えば、次のコードはパターンとして <code>...</code> を使っているため、Rust 2021 ではただのリントではなくエラーが発生します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn less_or_eq_to_100(n: u8) -&gt; bool {
  matches!(n, 0...100) // should be `0..=100`
                       // `0..=100` と書かなくてはならない
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Migrations 
-->
<h2 id="移行-6"><a class="header" href="#移行-6">移行</a></h2>
<!--
If your Rust 2015 or 2018 code does not produce any warnings for `bare_trait_objects` 
or `ellipsis_inclusive_range_patterns` and you've not allowed these lints through the 
use of `#![allow()]` or some other mechanism, then there's no need to migrate.
-->
<p>あなたの Rust 2015 か 2018 のコードで、<code>bare_trait_objects</code> や <code>ellipsis_inclusive_range_patterns</code> といったエラーが出ず、<code>#![allow()]</code> などを使ってこれらのリントを許可する設定をしていなければ、移行の際にやることはありません。</p>
<!--
To automatically migrate any crate that uses `...` in patterns or does not use `dyn` with
trait objects, you can run `cargo fix --edition`.
-->
<p><code>...</code> をパターンに使用していたり、トレイトオブジェクトに <code>dyn</code> を使っていないクレートがある場合は、
<code>cargo fix --edition</code> を実行すればよいです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Or patterns in macro-rules
-->
<h1 id="マクロ規則における-or-パターン"><a class="header" href="#マクロ規則における-or-パターン">マクロ規則における OR パターン</a></h1>
<!--
## Summary
-->
<h2 id="概要-8"><a class="header" href="#概要-8">概要</a></h2>
<!--
- How patterns work in `macro_rules` macros changes slightly:
	- `$_:pat` in `macro_rules` now matches usage of `|` too: e.g. `A | B`.
	- The new `$_:pat_param` behaves like `$_:pat` did before; it does not match (top level) `|`.
	- `$_:pat_param` is available in all editions.
-->
<ul>
<li><code>macro_rules</code> におけるパターンの挙動がほんの少し変更されました:
<ul>
<li><code>macro_rules</code> において、<code>$_:pat</code> で <code>|</code> を使ったパターンにもマッチするようになりました。例えば、<code>A | B</code> にマッチします。</li>
<li>新しく導入された <code>$_:pat_param</code> は、かつての <code>$_:pat</code> と同じ挙動を再現します。すなわち、こちらは（トップレベルの）<code>|</code> にはマッチしません。</li>
<li><code>$_:pat_param</code> は全てのエディションで使用可能です。</li>
</ul>
</li>
</ul>
<!--
## Details
-->
<h2 id="詳細-8"><a class="header" href="#詳細-8">詳細</a></h2>
<!--
Starting in Rust 1.53.0, [patterns](https://doc.rust-lang.org/stable/reference/patterns.html)
are extended to support `|` nested anywhere in the pattern.
This enables you to write `Some(1 | 2)` instead of `Some(1) | Some(2)`.
Since this was simply not allowed before, this is not a breaking change.
-->
<p>Rust 1.53.0 から、<a href="https://doc.rust-lang.org/stable/reference/patterns.html">パターン</a>中のどこでも、<code>|</code> をネストして使えるようになりました。
これにより、<code>Some(1) | Some(2)</code> でなく <code>Some(1 | 2)</code> と書くことができるようになりました。
今まではこうは書けなかったので、これは破壊的変更ではありません。</p>
<!--
However, this change also affects [`macro_rules` macros](https://doc.rust-lang.org/stable/reference/macros-by-example.html).
Such macros can accept patterns using the `:pat` fragment specifier.
Currently, `:pat` does *not* match top level `|`, since before Rust 1.53,
not all patterns (at all nested levels) could contain a `|`.
Macros that accept patterns like `A | B`,
such as [`matches!()`](https://doc.rust-lang.org/1.51.0/std/macro.matches.html)
use something like `$($_:pat)|+`. 
-->
<p>ところが、この変更は <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html"><code>macro_rules</code> で定義されたマクロ</a> にも影響します。
<code>macro_rules</code> では、<code>:pat</code> というフラグメント指定子で、パターンを受け付けることができます。
現在のところ、<code>:pat</code> はトップレベルの <code>|</code> にマッチ<em>しません</em>。
なぜなら Rust 1.53 以前は、全てのパターンが（どのネストレベルにでも）<code>|</code> を含むことができるわけではなかったからです。
<a href="https://doc.rust-lang.org/1.51.0/std/macro.matches.html"><code>matches!()</code></a> のように、
<code>A | B</code> のようなパターンを受け付けるマクロを書くには、
<code>$($_:pat)|+</code> のような書き方をしなくてはなりませんでした。</p>
<!--
Because this would potentially break existing macros, the meaning of `:pat` did 
not change in Rust 1.53.0 to include `|`. Instead, that change happens in Rust 2021. 
In the new edition, the `:pat` fragment specifier *will* match `A | B`.
-->
<p>既存のマクロを壊す可能性があるため、Rust 1.53.0 では <code>:pat</code> が <code>|</code> を含むことができるようには変更されませんでした。
代わりに、Rust 2021 で変更がなされました。
新しいエディションでは、<code>:pat</code> フラグメント指定子は <code>A | B</code> にマッチ<em>します</em>。</p>
<!--
`$_:pat` fragments in Rust 2021 cannot be followed by an explicit `|`. Since there are times 
that one still wishes to match pattern fragments followed by a `|`, the fragment specified `:pat_param` 
has been added to retain the older behavior.
-->
<p>Rust 2021 では、<code>$_:pat</code> フラグメントに <code>|</code> そのものを続けることはできません。
パターンフラグメントに <code>|</code> が続いてるものにマッチさせたいような場合は、新しく追加された <code>:pat_param</code> が過去と同じ挙動を示すようになっています。</p>
<!--
It's important to remember that editions are _per crate_, so the only relevant edition is the edition
of the crate where the macro is defined. The edition of the crate where the macro is used does not 
change how the macro works.
-->
<p>ただし、エディションは<!-- --><em>クレートごとに</em><!-- -->設定されることに注意してください。
つまり、マクロが定義されているクレートのエディションだけが関係します。
マクロを使用する方のクレートのエディションは、マクロの挙動に影響しません。</p>
<!--
## Migration 
-->
<h2 id="移行-7"><a class="header" href="#移行-7">移行</a></h2>
<!--
A lint, `rust_2021_incompatible_or_patterns`, gets triggered whenever there is a use `$_:pat` which
will change meaning in Rust 2021. 
-->
<p><code>$_:pat</code> が使われている場所のうち、Rust 2021 で意味が変わるようなものに対しては、<code>rust_2021_incompatible_or_patterns</code> というリントが発生します。</p>
<!--
You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:
-->
<p>コードを自動的に Rust 2021 エディションに適合するよう自動移行するか、既に適合するものであることを確認するためには、以下のように実行すればよいです:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<!--
If you have a macro which relies on `$_:pat` not matching the top level use of `|` in patterns, 
you'll need to change each occurrence of `$_:pat` to `$_:pat_param`.
-->
<p>あなたのマクロが、<code>$_:pat</code> がトップレベルの <code>|</code> にマッチしないという挙動に依存している場合は、
<code>$_:pat</code> を <code>$_:pat_param</code> に書き換える必要があります。</p>
<!--
For example:
-->
<p>例えば以下のようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro { 
	($x:pat | $y:pat) =&gt; {
		// TODO: implementation
		// TODO: 実装
	}
}

// This macro works in Rust 2018 since `$x:pat` does not match against `|`:
// Rust 2018 では、`$x:pat` が `|` にマッチしないので、以下のマクロは正常に動きます:
my_macro!(1 | 2);

// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not allowed
// to be followed by a `|`. To make sure this macro still works in Rust 2021
// change the macro to the following:
// 一方 Rust 2021 では、`$_:pat` フラグメントは `|` にもマッチし、
// `|` が続くのは許されなくなりました。
// Rust 2021 でもマクロが動作するためには、マクロを以下のように変更しなくてはなりません:
macro_rules! my_macro { 
	($x:pat_param | $y:pat) =&gt; { // &lt;- this line is different
	                             //    この行を変えた
		// TODO: implementation
		// TODO: 実装
	} 
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
