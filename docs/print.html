<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>エディションガイド</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/em-to-bold.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">序文</a></li><li class="chapter-item expanded "><a href="editions/index.html"><strong aria-hidden="true">1.</strong> エディションとは？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="editions/creating-a-new-project.html"><strong aria-hidden="true">1.1.</strong> 新しいプロジェクトを作成する</a></li><li class="chapter-item expanded "><a href="editions/transitioning-an-existing-project-to-a-new-edition.html"><strong aria-hidden="true">1.2.</strong> 既存のプロジェクトのエディションを移行する</a></li><li class="chapter-item expanded "><a href="editions/advanced-migrations.html"><strong aria-hidden="true">1.3.</strong> Advanced migrations</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li class="chapter-item expanded "><a href="rust-2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2018/path-changes.html"><strong aria-hidden="true">3.1.</strong> Path and module system changes</a></li><li class="chapter-item expanded "><a href="rust-2018/trait-fn-parameters.html"><strong aria-hidden="true">3.2.</strong> Anonymous trait function parameters deprecated</a></li><li class="chapter-item expanded "><a href="rust-2018/new-keywords.html"><strong aria-hidden="true">3.3.</strong> New keywords</a></li><li class="chapter-item expanded "><a href="rust-2018/tyvar-behind-raw-pointer.html"><strong aria-hidden="true">3.4.</strong> Method dispatch for raw pointers to inference variables</a></li><li class="chapter-item expanded "><a href="rust-2018/cargo.html"><strong aria-hidden="true">3.5.</strong> Cargo changes</a></li></ol></li><li class="chapter-item expanded "><a href="rust-post-2018/index.html"><strong aria-hidden="true">4.</strong> Rust 2018以降の変更（期間限定公開）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-post-2018/dbg-macro.html"><strong aria-hidden="true">4.1.</strong> dbg! マクロ</a></li><li class="chapter-item expanded "><a href="rust-post-2018/no-jemalloc.html"><strong aria-hidden="true">4.2.</strong> デフォルトでjemallocを使わない</a></li><li class="chapter-item expanded "><a href="rust-post-2018/uniform-paths.html"><strong aria-hidden="true">4.3.</strong> 統一的なパス</a></li><li class="chapter-item expanded "><a href="rust-post-2018/literal-macro-matcher.html"><strong aria-hidden="true">4.4.</strong> リテラルマクロマッチャ</a></li><li class="chapter-item expanded "><a href="rust-post-2018/qustion-mark-operator-in-macros.html"><strong aria-hidden="true">4.5.</strong> マクロ内の?演算子</a></li><li class="chapter-item expanded "><a href="rust-post-2018/const-fn.html"><strong aria-hidden="true">4.6.</strong> const fn</a></li><li class="chapter-item expanded "><a href="rust-post-2018/pin.html"><strong aria-hidden="true">4.7.</strong> ピン留め</a></li><li class="chapter-item expanded "><a href="rust-post-2018/no-more-fnbox.html"><strong aria-hidden="true">4.8.</strong> FnBoxは不要に</a></li><li class="chapter-item expanded "><a href="rust-post-2018/alternative-cargo-registries.html"><strong aria-hidden="true">4.9.</strong> Cargoレジストリが選択できるように</a></li><li class="chapter-item expanded "><a href="rust-post-2018/tryfrom-and-tryinto.html"><strong aria-hidden="true">4.10.</strong> TryFromとTryInto</a></li><li class="chapter-item expanded "><a href="rust-post-2018/future.html"><strong aria-hidden="true">4.11.</strong> Futureトレイト</a></li><li class="chapter-item expanded "><a href="rust-post-2018/alloc.html"><strong aria-hidden="true">4.12.</strong> allocクレート</a></li><li class="chapter-item expanded "><a href="rust-post-2018/maybe-uninit.html"><strong aria-hidden="true">4.13.</strong> MaybeUninit</a></li><li class="chapter-item expanded "><a href="rust-post-2018/cargo-vendor.html"><strong aria-hidden="true">4.14.</strong> cargo vendor</a></li></ol></li><li class="chapter-item expanded "><a href="rust-2021/index.html"><strong aria-hidden="true">5.</strong> Rust 2021</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-2021/prelude.html"><strong aria-hidden="true">5.1.</strong> Additions to the prelude</a></li><li class="chapter-item expanded "><a href="rust-2021/default-cargo-resolver.html"><strong aria-hidden="true">5.2.</strong> Default Cargo feature resolver</a></li><li class="chapter-item expanded "><a href="rust-2021/IntoIterator-for-arrays.html"><strong aria-hidden="true">5.3.</strong> IntoIterator for arrays</a></li><li class="chapter-item expanded "><a href="rust-2021/disjoint-capture-in-closures.html"><strong aria-hidden="true">5.4.</strong> Disjoint capture in closures</a></li><li class="chapter-item expanded "><a href="rust-2021/panic-macro-consistency.html"><strong aria-hidden="true">5.5.</strong> Panic macro consistency</a></li><li class="chapter-item expanded "><a href="rust-2021/reserving-syntax.html"><strong aria-hidden="true">5.6.</strong> Reserving syntax</a></li><li class="chapter-item expanded "><a href="rust-2021/warnings-promoted-to-error.html"><strong aria-hidden="true">5.7.</strong> Warnings promoted to errors</a></li><li class="chapter-item expanded "><a href="rust-2021/or-patterns-macro-rules.html"><strong aria-hidden="true">5.8.</strong> Or patterns in macro-rules</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">エディションガイド</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-ja/edition-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#序文" id="序文">序文</a></h1>
<!-- # Introduction -->
<!-- Welcome to the Rust Edition Guide! "Editions" are Rust's way of -->
<!-- communicating large changes in the way that it feels to write Rust -->
<!-- code. -->
<p>Rust エディションガイドへようこそ！「エディション」とは、Rust でのコードの書き方
における重大な変化をあなたに伝えるためにあるものです。</p>
<!-- In this guide, we'll discuss: -->
<p>このガイドでは、下記の項目について説明します：</p>
<!-- * What editions are -->
<!-- * What each edition is about -->
<!-- * How to migrate your code from one edition to another -->
<ul>
<li>エディションとは何か</li>
<li>各エディションの内容</li>
<li>コードをあるエディションから別のエディションへ移行する方法</li>
</ul>
<!-- Note that the standard library grows with each Rust release; there are -->
<!-- *many* additions to the standard library that are not called out in -->
<!-- this guide. Only the major ones are, but there's tons of medium and -->
<!-- small things that are great too. You may want to check out [the -->
<!-- standard library documentation](https://doc.rust-lang.org/std/) as -->
<!-- well. -->
<p>Rust が新しくリリースされるとともに、標準ライブラリは発展します。標準ライブラリ
へ追加される機能のうち、重要なものだけがこのガイドに記載されていますが、記載は
ないものの、すばらしい機能も沢山追加されています。
<a href="https://doc.rust-lang.org/std/">標準ライブラリのドキュメンテーション</a>も是非
ご覧ください。</p>
<!--
# What are Editions?
-->
<h1><a class="header" href="#エディションとは" id="エディションとは">エディションとは？</a></h1>
<!--
Rust ships releases on a six-week cycle. This means that users get a constant
stream of new features. This is much faster than updates for other languages,
but this also means that each update is smaller.  After a while, all of those
tiny changes add up. But, from release to release, it can be hard to look back
and say *"Wow, between Rust 1.10 and Rust 1.20, Rust has changed a lot!"*
-->
<p>Rustは6週間ごとにリリースを行います。
これにより、ユーザーは新しい機能を常に手に入れることができます。
これは他の言語よりも速いサイクルですが、アップデートのサイズは小さくなります。
しばらくするとこれらの小変更が積み重なってきますが、いくつかのリリースを振り返って、「おお、バージョン1.10から1.20の間にRustは大きく変わったなぁ」と言うのは難しいかも知れません。</p>
<!--
Every two or three years, we'll be producing a new *edition* of Rust. Each
edition brings together the features that have landed into a clear package, with
fully updated documentation and tooling. New editions ship through the usual
release process.
-->
<p>2,3年に一度、Rustの新しい「エディション」を作成します。
各エディションはそれまでRustに加えられた変更をまとめ上げたもので、最新のドキュメントとツールもそれに含まれます。
新しいエディションは通常のリリースプロセスを経てリリースされます。</p>
<!--
This serves different purposes for different people:

- For active Rust users, it brings together incremental changes into an
  easy-to-understand package.

- For non-users, it signals that some major advancements have landed, which
  might make Rust worth another look.

- For those developing Rust itself, it provides a rallying point for the project as a
  whole.
  -->
<p>エディションは様々な人の異なる要求を満たします。</p>
<ul>
<li>
<p>Rustのアクティブなユーザーにとっては、6週間ごとににリリースされた機能変更をわかりやすくまとめたパッケージとなります。</p>
</li>
<li>
<p>Rustを使っていない人にとっては、大きな変更が施されたことを知らせる役割を果たし、それによってRustを使ってみようと思うようになるかも知れません。</p>
</li>
<li>
<p>Rustの内部開発者にとっては、プロジェクト全体の長期的なゴールになります。</p>
</li>
</ul>
<!--
## Compatibility
-->
<h2><a class="header" href="#互換性" id="互換性">互換性</a></h2>
<!--
When a new edition becomes available in the compiler, crates must explicitly opt
in to it to take full advantage. This opt in enables editions to contain
incompatible changes, like adding a new keyword that might conflict with
identifiers in code, or turning warnings into errors. A Rust compiler will
support all editions that existed prior to the compiler's release, and can link
crates of any supported editions together.
Edition changes only affect the way the compiler initially parses the code.
Therefore, if you're using Rust 2015, and
one of your dependencies uses Rust 2018, it all works just fine. The opposite
situation works as well.
-->
<p>新しいエディションがコンパイラで利用可能になった際に、その利点を最大限に活かすためには、クレートは明示的にオプトインする必要があります。
このオプトインはエディションに非互換の変更を加えるために必要で、例えば、既存のコードで使われている識別子と競合する新たなキーワードを導入したり、警告だったものをエラーにする、などの変更を加えることができるようになります。
Rustのコンパイラはこれまでの全てのエディションをサポートしていて、複数のクレートが異なるエディションを使用していても一つにリンクできます。
エディションの変更はコンパイラが最初にコードを構文解析する際の動作のみに影響します。
従って、例ばあなたがRust 2015を使っていて、依存するクレートが Rust 2018を使っていても全く問題なく動作します。
その逆の場合も同様です。</p>
<!--
Just to be clear: most features will be available on all editions.
People using any edition of Rust will continue to see improvements as new
stable releases are made.  In some cases however, mainly when new keywords are
added, but sometimes for other reasons, there may be new features that are only
available in later editions.  You only need to upgrade if you want to take
advantage of such features.
-->
<p>念の為はっきりさせておきますが、ほとんどの機能は全てのエディションで利用可能です。
どのエディションを利用していても、新たな安定板リリースが出た際には改善を見ることができます。
時折、例えば新たなキーワードが導入されたりその他の理由で、あるエディション以降でしか利用できない機能追加があります。
そのような機能を利用したい時にエディションのアップデートを検討するのが良いでしょう。</p>
<!--
# Creating a new project

When you create a new project with Cargo, it will automatically add
configuration for the latest edition:
-->
<h1><a class="header" href="#新しいプロジェクトを作成する" id="新しいプロジェクトを作成する">新しいプロジェクトを作成する</a></h1>
<p>Cargoは新たなプロジェクトを作成する際に自動で最新のエディションをコンフィギュレーションに追加します。</p>
<pre><code class="language-console">&gt; cargo +nightly new foo
     Created binary (application) `foo` project
&gt; cat foo/Cargo.toml
[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;your name &lt;you@example.com&gt;&quot;]
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<!--
That `edition = "2021"` setting will configure your package to use Rust 2021.
No more configuration needed!

If you'd prefer to use an older edition, you can change the value in that
key, for example:
-->
<p>この <code>edition = &quot;2021&quot;</code> によってあなたのパッケージが Rust 2021 を利用するように設定されます。
これ以外は必要ありません。</p>
<p>もし、他の古いエディションを使いたい場合は、その設定の値を変更できます。例えば、</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;your name &lt;you@example.com&gt;&quot;]
edition = &quot;2015&quot;

[dependencies]
</code></pre>
<!--
This will build your package in Rust 2015.
-->
<p>とすると、あなたのパッケージは Rust 2015 でビルドされます。</p>
<!--
# Transitioning an existing project to a new edition
-->
<h1><a class="header" href="#既存のプロジェクトのエディションを移行する" id="既存のプロジェクトのエディションを移行する">既存のプロジェクトのエディションを移行する</a></h1>
<!--
New editions might change the way you write Rust – they add new syntax,
language, and library features, and also remove features. For example, `try`,
`async`, and `await` are keywords in Rust 2018, but not Rust 2015. If you
have a project that's using Rust 2015, and you'd like to use Rust 2018 for it
instead, there's a few steps that you need to take.
-->
<p>新たなエディションによってRustの書き方が変わるかも知れません。
新しい構文や新たなライブラリ機能の追加、そして時に機能の削除もあります。
例えば、<code>try</code>、<code>async</code>、<code>await</code>は Rust 2018ではキーワードですが、Rust 2015ではそうではありません。
もしあなたが Rust 2015のプロジェクトを持っていて、それを Rust 2018に移行したい場合には、やらなければならないことが幾つかあります。</p>
<!--
> It's our intention that the migration to new editions is as smooth an
> experience as possible. If it's difficult for you to upgrade to Rust 2018,
> we consider that a bug. If you run into problems with this process, please
> [file a bug](https://github.com/rust-lang/rust/issues/new). Thank you!
-->
<blockquote>
<p>我々は、新しいエディションへの移行をできるだけスムーズに行えるようにしたいと考えています。
もし、Rust 2018へアップグレードするのが大変な場合は、我々はそれをバグとみなします。
もし移行時に問題があった場合には<a href="https://github.com/rust-lang/rust/issues/new">バグ登録</a>してください。</p>
<p>訳注：Rustの日本語コミュニティもあります。
Slackを使用しており<a href="https://rust-jp.herokuapp.com/">こちら</a>から登録できます。</p>
</blockquote>
<!--
Here's an example. Imagine we have a crate that has this code in
`src/lib.rs`:
-->
<p>ここに例を挙げます。<code>src/lib.rs</code>に以下のコードがあるクレートがあるとします。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, Box&lt;Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code uses an anonymous parameter, that `Box<Foo>`. This is [not
supported in Rust 2018](../rust-2018/trait-system/no-anon-params.md), and
so this would fail to compile. Let's get this code up to date!
-->
<p>このコードは <code>Box&lt;Foo&gt;</code>という無名パラメータを使用しています。
これは <a href="editions/../rust-2018/trait-system/no-anon-params.html">Rust 2018ではサポートされておらず</a>、コンパイルに失敗します。
このコードを更新してみましょう。</p>
<!--
## Updating your code to be compatible with the new edition
-->
<h2><a class="header" href="#あなたのコードを新しいエディションでコンパイルできるようにする" id="あなたのコードを新しいエディションでコンパイルできるようにする">あなたのコードを新しいエディションでコンパイルできるようにする</a></h2>
<!--
Your code may or may not use features that are incompatible with the new
edition. In order to help transition to Rust 2018, we've included a new
subcommand with Cargo. To start, let's run it:
-->
<p>あなたのコードは互換性のない機能を使っているかも知れないし、使っていないかも知れません。
Rust 2018への移行を助けるためにCargoに新しいサブコマンドを追加しました。
まず初めにそれを起動してみましょう。</p>
<pre><code class="language-console">&gt; cargo fix --edition
</code></pre>
<!--
This will check your code, and automatically fix any issues that it can.
Let's look at `src/lib.rs` again:
-->
<p>これはあなたのコードをチェックして、自動的に移行の問題を修正してくれます。
もう一度 <code>src/lib.rs</code>を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: Box&lt;Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
It's re-written our code to introduce a parameter name for that trait object.
In this case, since it had no name, `cargo fix` will replace it with `_`,
which is conventional for unused variables.
-->
<p>トレイトオブジェクトのためのパラメータ名が追加された形でコードが書き換えられています。
この場合は、パラメータ名がなかったので、使用されていないパラメータの慣習に従って <code>_</code> を付加しています。</p>
<!--
`cargo fix` can't always fix your code automatically.
If `cargo fix` can't fix something, it will print the warning that it cannot fix
to the console. If you see one of these warnings, you'll have to update your code
manually. See the corresponding section of this guide for help, and if you have
problems, please seek help at the [user's forums](https://users.rust-lang.org/).
-->
<p><code>Cargo fix</code>は常に自動的にコードを修正してくれるわけではありません。
もし、<code>cargo fix</code>がコードを修正できない時にはコンソールに修正できなかったという警告を表示します。
その場合は手動でコードを修正してください。
助けが必要な時は、このガイドの対応するセクションを参照してください。
問題がある場合は、 <a href="https://users.rust-lang.org/">ユーザーフォーラム</a>で助けを求めてください。</p>
<!--
Keep running `cargo fix --edition` until you have no more warnings.
-->
<p>そして警告が出なくなるまで <code>cargo fix --edition</code> を繰り返し実行してください。</p>
<!--
Congrats! Your code is now valid in both Rust 2015 and Rust 2018!
-->
<p>おめでとうございます！ あなたのコードはRust 2015とRust 2018の双方で正しいコードになりました。</p>
<!--
## Enabling the new edition to use new features
-->
<h2><a class="header" href="#新機能を使うために新たなエディションを有効化する" id="新機能を使うために新たなエディションを有効化する">新機能を使うために新たなエディションを有効化する</a></h2>
<!--
In order to use some new features, you must explicitly opt in to the new
edition. Once you're ready to commit, change your `Cargo.toml` to add the new
`edition` key/value pair. For example:
-->
<p>新しいエディションの新機能を使うには明示的にオプトインする必要があります。
コミットする準備ができたら、<code>Cargo.toml</code>に新しいエディションのキーバリューペアを追加してください。
例えば以下のような形になります。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;
</code></pre>
<!--
If there's no `edition` key, Cargo will default to Rust 2015. But in this case,
we've chosen `2018`, and so our code is compiling with Rust 2018!
-->
<p>もし <code>edition</code>キーがなければCargoはデフォルトで Rust 2015をエディションとして使います。
しかし上記の例では、<code>2018</code>を明示的に指定しているのでコードは Rust 2018でビルドされます。</p>
<!--
## Writing idiomatic code in a new edition
-->
<h2><a class="header" href="#新しいエディションで慣用的なコードを書く" id="新しいエディションで慣用的なコードを書く">新しいエディションで慣用的なコードを書く</a></h2>
<!--
Editions are not only about new features and removing old ones. In any programming
language, idioms change over time, and Rust is no exception. While old code
will continue to compile, it might be written with different idioms today.
-->
<p>エディションは新機能を追加したり機能を削除するだけのものではありません。
どのようなプログラミング言語でも、イディオム（プログラムの書き方のスタイル）は時と共に変化していきます。
Rustも例外ではありません。
古いスタイルのコードは引き続きコンパイル可能ですが、新しいエディションでは違った書き方で書いた方が良いかも知れません。</p>
<!--
Our sample code contains an outdated idiom. Here it is again:
-->
<p>我々のサンプルコードは古いスタイルを含んでいます。
もう一度ここにそのコードを示します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: Box&lt;Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust 2018, it's considered idiomatic to use the [`dyn`
keyword](../rust-2018/trait-system/dyn-trait-for-trait-objects.md) for
trait objects.
-->
<p>Rust 2018では、トレイトオブジェクトに <a href="editions/../rust-2018/trait-system/dyn-trait-for-trait-objects.html"><code>dyn</code> キーワード</a> を付けるのが良いとされています。</p>
<!--
Eventually, we want `cargo fix` to fix all these idioms automatically in the same
manner we did for upgrading to the 2018 edition. **Currently,
though, the *"idiom lints"* are not ready for widespread automatic fixing.** The
compiler isn't making `cargo fix`-compatible suggestions in many cases right
now, and it is making incorrect suggestions in others. Enabling the idiom lints,
even with `cargo fix`, is likely to leave your crate either broken or with many
warnings still remaining.
-->
<p>いずれ、<code>cargo fix</code>によってこのようなイディオムの変更も、2018エディションへアップグレードしたときのように自動的に行いたいと考えています。
<strong>ただし今現在は、イディオムチェッカーが広範囲の自動修正をできるレベルにはなっていません。</strong>
今のところ、コンパイラは多くの場合 <code>cargo fix</code>互換のサジェスチョンを出さなかったり、間違ったサジェスチョンを出したりします。
<code>cargo fix</code>と共にイディオムチェッカーを有効にすると、おそらくはあなたのコードを壊してしまったり、多くの警告が残り続けるということになってしまいます。</p>
<!--
We have plans to make these idiom migrations a seamless part of the Rust 2018
experience, but we're not there yet. As a result the following instructions are
recommended only for the intrepid who are willing to work through a few
compiler/Cargo bugs!
-->
<p>Rust 2018の体験の一部として、シームレスなイディオム移行を提供する計画があります。
しかしまだそこには至っていません。
したがって、以下の手順はコンパイラやCargoのバグを乗り越えることを厭わない勇猛な方のみにお勧めします。</p>
<!--
With that out of the way, we can instruct Cargo to fix our code snippet with:
-->
<p>以上を踏まえたうえで、私たちのコード片をCargoに修正させてみましょう。</p>
<pre><code class="language-console">$ cargo fix --edition-idioms
</code></pre>
<!--
Afterwards, `src/lib.rs` looks like this:
-->
<p>実行後は <code>src/lib.rs</code>は以下のようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: Box&lt;dyn Foo&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
We're now more idiomatic, and we didn't have to fix our code manually!
-->
<p>これでコードはより新しいスタイルになりました。
手修正する必要はありませんでした。</p>
<!--
Note that `cargo fix` may still not be able to automatically update our code.
If `cargo fix` can't fix something, it will print a warning to the console, and
you'll have to fix it manually.
-->
<p>なお、<code>cargo fix</code>はコードを自動的に改修することができない場合もあることを覚えておいてください。
その場合は <code>cargo fix</code>は警告メッセージを出すので、それを見て手動でコードを修正してください。</p>
<!--
As mentioned before, there are known bugs around the idiom lints which
means they're not all ready for prime time yet. You may get a scary-looking
warning to report a bug to Cargo, which happens whenever a fix proposed by
`rustc` actually caused code to stop compiling by accident. If you'd like `cargo
fix` to make as much progress as possible, even if it causes code to stop
compiling, you can execute:
-->
<p>上でも述べたようにイディオムチェッカーには幾つかわかっているバグがあり、まだ実践登用できるレベルではありません。
Cargoのバグレポートを出すようにという恐ろしげな警告を見るかも知れませんが、これは <code>rustc</code>によって提案された修正が誤ってコードをコンパイルできなくしてしまった時に起こります。
もしコンパイルが止まったとしても <code>cargo fix</code>を使ってできるだけ自動修正をしたい場合には以下のコマンドを使います。</p>
<pre><code class="language-console">$ cargo fix --edition-idioms --broken-code
</code></pre>
<!--
This will instruct `cargo fix` to apply automatic suggestions regardless of
whether they work or not. Like usual, you'll see the compilation result after
all fixes are applied. If you notice anything wrong or unusual, please feel free
to report an issue to Cargo and we'll help prioritize and fix it.
-->
<p>これは、動くかどうかは関係なく<code>cargo fix</code>に自動修正を行わせます。
全ての修正が適用された後にコードはコンパイルされてその結果を見ることができます。
もし何か間違いや異常に気がついた時は、お気軽にCargoにバグ報告してください。</p>
<!--
Enjoy the new edition!
-->
<p>それでは、新しいエディションをお楽しみください！</p>
<h1><a class="header" href="#advanced-migration-strategies" id="advanced-migration-strategies">Advanced migration strategies</a></h1>
<h2><a class="header" href="#how-migrations-work" id="how-migrations-work">How migrations work</a></h2>
<p><a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix --edition</code></a> works by running the equivalent of <a href="https://doc.rust-lang.org/cargo/commands/cargo-check.html"><code>cargo check</code></a> on your project with special <a href="https://doc.rust-lang.org/rustc/lints/index.html">lints</a> enabled which will detect code that may not compile in the next edition.
These lints include instructions on how to modify the code to make it compatible on both the current and the next edition.
<code>cargo fix</code> applies these changes to the source code, and then runs <code>cargo check</code> again to verify that the fixes work.
If the fixes fail, then it will back out the changes and display a warning.</p>
<p>Changing the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code.
If the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing <code>Cargo.toml</code> to use the next edition.</p>
<p>The lints that <code>cargo fix --edition</code> apply are part of a <a href="https://doc.rust-lang.org/rustc/lints/groups.html">lint group</a>.
For example, when migrating from 2018 to 2021, Cargo uses the <code>rust-2021-compatibility</code> group of lints to fix the code.
Check the <a href="editions/advanced-migrations.html#partial-migration-with-broken-code">Partial migration</a> section below for tips on using individual lints to help with migration.</p>
<p><code>cargo fix</code> may run <code>cargo check</code> multiple times.
For example, after applying one set of fixes, this may trigger new warnings which require further fixes.
Cargo repeats this until no new warnings are generated.</p>
<h2><a class="header" href="#migrating-multiple-configurations" id="migrating-multiple-configurations">Migrating multiple configurations</a></h2>
<p><code>cargo fix</code> can only work with a single configuration at a time.
If you use <a href="https://doc.rust-lang.org/cargo/reference/features.html">Cargo features</a> or <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a>, then you may need to run <code>cargo fix</code> multiple times with different flags.</p>
<p>For example, if you have code that uses <code>#[cfg]</code> attributes to include different code for different platforms, you may need to run <code>cargo fix</code> with the <code>--target</code> option to fix for different targets.
This may require moving your code between machines if you don't have cross-compiling available.</p>
<p>Similarly, if you have conditions on Cargo features, like <code>#[cfg(feature = &quot;my-optional-thing&quot;)]</code>, it is recommended to use the <code>--all-features</code> flag to allow <code>cargo fix</code> to migrate all the code behind those feature gates.
If you want to migrate feature code individually, you can use the <code>--features</code> flag to migrate one at a time.</p>
<h2><a class="header" href="#migrating-a-large-project-or-workspace" id="migrating-a-large-project-or-workspace">Migrating a large project or workspace</a></h2>
<p>You can migrate a large project incrementally to make the process easier if you run into problems.</p>
<p>In a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo workspace</a>, each package defines its own edition, so the process naturally involves migrating one package at a time.</p>
<p>Within a <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-package-section">Cargo package</a>, you can either migrate the entire package at once, or migrate individual <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html">Cargo targets</a> one at a time.
For example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with <code>cargo fix --edition</code> to migrate just that one target.
By default, <code>cargo fix</code> uses <code>--all-targets</code>.</p>
<p>For even more advanced cases, you can specify the edition for each individual target in <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[[bin]]
name = &quot;my-binary&quot;
edition = &quot;2018&quot;
</code></pre>
<p>This usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.</p>
<h2><a class="header" href="#partial-migration-with-broken-code" id="partial-migration-with-broken-code">Partial migration with broken code</a></h2>
<p>Sometimes the fixes suggested by the compiler may fail to work.
When this happens, Cargo will report a warning indicating what happened and what the error was.
However, by default it will automatically back out the changes it made.
It can be helpful to keep the code in the broken state and manually resolve the issue.
Some of the fixes may have been correct, and the broken fix maybe be <em>mostly</em> correct, but just need minor tweaking.</p>
<p>In this situation, use the <code>--broken-code</code> option with <code>cargo fix</code> to tell Cargo not to back out the changes.
Then, you can go manually inspect the error and investigate what is needed to fix it.</p>
<p>Another option to incrementally migrate a project is to apply individual fixes separately, one at a time.
You can do this by adding the individual lints as warnings, and then either running <code>cargo fix</code> (without the <code>--edition</code> flag) or using your editor or IDE to apply its suggestions if it supports &quot;Quick Fixes&quot;.</p>
<p>For example, the 2018 edition uses the <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#keyword-idents"><code>keyword-idents</code></a> lint to fix any conflicting keywords.
You can add <code>#![warn(keyword_idents)]</code> to the top of each crate (like at the top of <code>src/lib.rs</code> or <code>src/main.rs</code>).
Then, running <code>cargo fix</code> will apply just the suggestions for that lint.</p>
<p>You can see the list of lints enabled for each edition in the <a href="https://doc.rust-lang.org/rustc/lints/groups.html">lint group</a> page, or run the <code>rustc -Whelp</code> command.</p>
<h2><a class="header" href="#migrating-macros" id="migrating-macros">Migrating macros</a></h2>
<p>Some macros may require manual work to fix them for the next edition.
For example, <code>cargo fix --edition</code> may not be able to automatically fix a macro that generates syntax that does not work in the next edition.</p>
<p>This may be a problem for both <a href="https://doc.rust-lang.org/reference/procedural-macros.html">proc macros</a> and <code>macro_rules</code>-style macros.
<code>macro_rules</code> macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot.
Proc macros in general cannot be automatically fixed at all.</p>
<p>For example, if we migrate a crate containing this (contrived) macro <code>foo</code> from 2015 to 2018, <code>foo</code> would not be automatically fixed.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    () =&gt; {
        let dyn = 1;
        println!(&quot;it is {}&quot;, dyn);
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>When this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below).
In 2015, <code>dyn</code> is a normal identifier and can be used without restriction.</p>
<p>However, in 2018, <code>dyn</code> is no longer a valid identifier.
When using <code>cargo fix --edition</code> to migrate to 2018, Cargo won't display any warnings or errors at all.
However, <code>foo</code> won't work when called from any crate.</p>
<p>If you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax.
You may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere.
If you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.</p>
<h3><a class="header" href="#macro-hygiene" id="macro-hygiene">Macro hygiene</a></h3>
<p>Macros use a system called &quot;edition hygiene&quot; where the tokens within a macro are marked with which edition they come from.
This allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.</p>
<p>Let's take a closer look at the example above that defines a <code>macro_rules</code> macro using <code>dyn</code> as an identifier.
If that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where <code>dyn</code> is a keyword and that would normally be a syntax error.
The <code>let dyn = 1;</code> tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded.
The parser looks at the edition of the tokens to know how to interpret it.</p>
<p>The problem arises when changing the edition to 2018 in the crate where it is defined.
Now, those tokens are tagged with the 2018 edition, and those will fail to parse.
However, since we never called the macro from our crate, <code>cargo fix --edition</code> never had a chance to inspect the macro and fix it.</p>
<!-- TODO: hopefully someday, the reference will have chapters on how expansion works, and this can link there for actual details. -->
<h2><a class="header" href="#documentation-tests" id="documentation-tests">Documentation tests</a></h2>
<p>At this time, <code>cargo fix</code> is not able to update <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">documentation tests</a>.
After updating the edition in <code>Cargo.toml</code>, you should run <code>cargo test</code> to ensure everything still passes.
If your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.</p>
<p>In rare cases, you can manually set the edition for each test.
For example, you can use the <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html#attributes"><code>edition2018</code> annotation</a> on the triple backticks to tell <code>rustdoc</code> which edition to use.</p>
<h2><a class="header" href="#generated-code" id="generated-code">Generated code</a></h2>
<p>Another area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see <a href="https://doc.rust-lang.org/cargo/reference/build-script-examples.html#code-generation">Code generation</a> for an example).
In this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.</p>
<h2><a class="header" href="#migrating-non-cargo-projects" id="migrating-non-cargo-projects">Migrating non-Cargo projects</a></h2>
<p>If your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition.
You can enable the migration lints as described above by enabling the appropriate <a href="https://doc.rust-lang.org/rustc/lints/groups.html">lint group</a>.
For example, you can use the <code>#![warn(rust_2021_compatibility)]</code> attribute or the <code>-Wrust-2021-compatibility</code> or <code>--force-warns=rust-2021-compatibility</code> <a href="https://doc.rust-lang.org/rustc/lints/levels.html#via-compiler-flag">CLI flag</a>.</p>
<p>The next step is to apply those lints to your code.
There are several options here:</p>
<ul>
<li>Manually read the warnings and apply the suggestions recommended by the compiler.</li>
<li>Use an editor or IDE that supports automatically applying suggestions.
For example, <a href="https://code.visualstudio.com/">Visual Studio Code</a> with the <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">Rust Analyzer extension</a> has the ability to use the &quot;Quick Fix&quot; links to automatically apply suggestions.
Many other editors and IDEs have similar functionality.</li>
<li>Write a migration tool using the <a href="https://github.com/rust-lang/rustfix"><code>rustfix</code></a> library.
This is the library that Cargo uses internally to take the <a href="https://doc.rust-lang.org/rustc/json.html">JSON messages</a> from the compiler and modify the source code.
Check the <a href="https://github.com/rust-lang/rustfix/tree/master/examples"><code>examples</code> directory</a> for examples of how to use the library.</li>
</ul>
<h2><a class="header" href="#writing-idiomatic-code-in-a-new-edition" id="writing-idiomatic-code-in-a-new-edition">Writing idiomatic code in a new edition</a></h2>
<p>Editions are not only about new features and removing old ones.
In any programming language, idioms change over time, and Rust is no exception.
While old code will continue to compile, it might be written with different idioms today.</p>
<p>For example, in Rust 2015, external crates must be listed with <code>extern crate</code> like this:</p>
<pre><code class="language-rust ignore">// src/lib.rs
extern crate rand;
</code></pre>
<p>In Rust 2018, it is <a href="editions/../rust-2018/path-changes.html#no-more-extern-crate">no longer necessary</a> to include these items.</p>
<p><code>cargo fix</code> has the <code>--edition-idioms</code> option to automatically transition some of these idioms to the new syntax.</p>
<blockquote>
<p><strong>Warning</strong>: The current <em>&quot;idiom lints&quot;</em> are known to have some problems.
They may make incorrect suggestions which may fail to compile.
The current lints are:</p>
<ul>
<li>Edition 2018:
<ul>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unused-extern-crates"><code>unused-extern-crates</code></a></li>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements"><code>explicit-outlives-requirements</code></a></li>
</ul>
</li>
<li>Edition 2021 does not have any idiom lints.</li>
</ul>
<p>The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs!
If you run into problems, you can try the <code>--broken-code</code> option <a href="editions/advanced-migrations.html#partial-migration-with-broken-code">described above</a> to make as much progress as possible, and then resolve the remaining issues manually.</p>
</blockquote>
<p>With that out of the way, we can instruct Cargo to fix our code snippet with:</p>
<pre><code class="language-console">cargo fix --edition-idioms
</code></pre>
<p>Afterwards, the line with <code>extern crate rand;</code> in <code>src/lib.rs</code> will be removed.</p>
<p>We're now more idiomatic, and we didn't have to fix our code manually!</p>
<!--
[`cargo check`]: ../../cargo/commands/cargo-check.html
[`cargo fix`]: ../../cargo/commands/cargo-fix.html
[`explicit-outlives-requirements`]:  ../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements
[`keyword-idents`]: ../../rustc/lints/listing/allowed-by-default.html#keyword-idents
[`rustfix`]: https://github.com/rust-lang/rustfix
[`unused-extern-crates`]: ../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates
[Cargo features]: ../../cargo/reference/features.html
[Cargo package]: ../../cargo/reference/manifest.html#the-package-section
[Cargo targets]: ../../cargo/reference/cargo-targets.html
[Cargo workspace]: ../../cargo/reference/workspaces.html
[CLI flag]: ../../rustc/lints/levels.html#via-compiler-flag
[Code generation]: ../../cargo/reference/build-script-examples.html#code-generation
[conditional compilation]: ../../reference/conditional-compilation.html
[documentation tests]: ../../rustdoc/documentation-tests.html
[JSON messages]: ../../rustc/json.html
[lint group]: ../../rustc/lints/groups.html
[lints]: ../../rustc/lints/index.html
[proc macros]: ../../reference/procedural-macros.html
[Rust Analyzer extension]: https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer
[rustdoc-annotation]: ../../rustdoc/documentation-tests.html#attributes
[rustfix-examples]: https://github.com/rust-lang/rustfix/tree/master/examples
[Visual Studio Code]: https://code.visualstudio.com/
-->
<h1><a class="header" href="#rust-2015" id="rust-2015">Rust 2015</a></h1>
<!--
Rust 2015 has a theme of "stability". It commenced with the release of 1.0,
and is the "default edition". The edition system was conceived in late 2017,
but Rust 1.0 was released in May of 2015. As such, 2015 is the edition
that you get when you don't specify any particular edition, for backwards
compatibility reasons.
-->
<p>Rust 2015は「安定性」というテーマを掲げています。
このエディションはRust 1.0のリリースから始まり、デフォルトのエディションとなっています。
エディションの仕組み自体は2017年末に考案されましたが、Rust 1.0は2015年5月にリリースされていて、「2015」が特定のエディションを指定しなかった時のデフォルトになります。</p>
<!--
"Stability" is the theme of Rust 2015 because 1.0 marked a huge change in
Rust development. Previous to Rust 1.0, Rust was changing on a daily basis.
This made it very difficult to write large software in Rust, and made it
difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed
to backwards compatibility, ensuring a solid foundation for people to build
projects on top of.
-->
<p>「安定性」がRust 2015エディションのテーマです。
なぜなら、Rust 1.0はRust開発に著しい変化をもたらしたからです。
Rust 1.0以前は、Rustは毎日のように変わっていました。
そのような言語は大規模なソフトウエア開発には使えないですし、学ぶことも難しいでしょう。
Rust 1.0とRust 2015エディションの登場とともに、我々は後方互換性にコミットし、Rust上で開発を行う人々のための強固な基盤を提供しています。</p>
<!--
Since it's the default edition, there's no way to port your code to Rust
2015; it just *is*. You'll be transitioning *away* from 2015, but never
really *to* 2015. As such, there's not much else to say about it!
-->
<p>Rust 2015はデフォルトのエディションなのであなたのコードをRust 2015へポーティングするということはありません。
どんなRustのコードもRust 2015<em>です</em>。
あなたは Rust 2015から<em>離れる</em>ことはあっても、<em>近づいていく</em>ということはありません。
ということで、これ以上あまり言うことはないでしょう！</p>
<h1><a class="header" href="#rust-2018" id="rust-2018">Rust 2018</a></h1>
<table><thead><tr><th>Info</th><th></th></tr></thead><tbody>
<tr><td>RFC</td><td><a href="https://rust-lang.github.io/rfcs/2052-epochs.html">#2052</a>, which also proposed the Edition system</td></tr>
<tr><td>Release version</td><td><a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">1.31.0</a></td></tr>
</tbody></table>
<p>The edition system was created for the release of Rust 2018. The release of the Rust 2018 edition coincided with a number of other features all coordinated around the theme of <em>productivity</em>. The majority of those features were backwards compatible and are now available on all editions; however, some of those changes required the edition mechanism (most notably the <a href="rust-2018/path-changes.html">module system changes</a>).</p>
<h1><a class="header" href="#path-and-module-system-changes" id="path-and-module-system-changes">Path and module system changes</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<ul>
<li>Paths in <code>use</code> declarations now work the same as other paths.</li>
<li>Paths starting with <code>::</code> must now be followed with an external crate.</li>
<li>Paths in <code>pub(in path)</code> visibility modifiers must now start with <code>crate</code>, <code>self</code>, or <code>super</code>.</li>
</ul>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>The module system is often one of the hardest things for people new to Rust. Everyone
has their own things that take time to master, of course, but there's a root
cause for why it's so confusing to many: while there are simple and
consistent rules defining the module system, their consequences can feel
inconsistent, counterintuitive and mysterious.</p>
<p>As such, the 2018 edition of Rust introduces a few new module system
features, but they end up <em>simplifying</em> the module system, to make it more
clear as to what is going on.</p>
<p>Here's a brief summary:</p>
<ul>
<li><code>extern crate</code> is no longer needed in 99% of circumstances.</li>
<li>The <code>crate</code> keyword refers to the current crate.</li>
<li>Paths may start with a crate name, even within submodules.</li>
<li>Paths starting with <code>::</code> must reference an external crate.</li>
<li>A <code>foo.rs</code> and <code>foo/</code> subdirectory may coexist; <code>mod.rs</code> is no longer needed
when placing submodules in a subdirectory.</li>
<li>Paths in <code>use</code> declarations work the same as other paths.</li>
</ul>
<p>These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall. Read on for more details!</p>
<h2><a class="header" href="#more-details" id="more-details">More details</a></h2>
<p>Let's talk about each new feature in turn.</p>
<h3><a class="header" href="#no-more-extern-crate" id="no-more-extern-crate">No more <code>extern crate</code></a></h3>
<p>This one is quite straightforward: you no longer need to write <code>extern crate</code> to
import a crate into your project. Before:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}
</code></pre>
<p>Now, to add a new crate to your project, you can add it to your <code>Cargo.toml</code>,
and then there is no step two. If you're not using Cargo, you already had to pass
<code>--extern</code> flags to give <code>rustc</code> the location of external crates, so you'd just
keep doing what you were doing there as well.</p>
<blockquote>
<p>One small note here: <code>cargo fix</code> will not currently automate this change. We may
have it do this for you in the future.</p>
</blockquote>
<h4><a class="header" href="#an-exception" id="an-exception">An exception</a></h4>
<p>There's one exception to this rule, and that's the &quot;sysroot&quot; crates. These are the
crates distributed with Rust itself.</p>
<p>Usually these are only needed in very specialized situations. Starting in
1.41, <code>rustc</code> accepts the <code>--extern=CRATE_NAME</code> flag which automatically adds
the given crate name in a way similar to <code>extern crate</code>. Build tools may use
this to inject sysroot crates into the crate's prelude. Cargo does not have a
general way to express this, though it uses it for <code>proc_macro</code> crates.</p>
<p>Some examples of needing to explicitly import sysroot crates are:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/index.html"><code>std</code></a>: Usually this is not neccesary, because <code>std</code> is automatically
imported unless the crate is marked with <a href="https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute"><code>#![no_std]</code></a>.</li>
<li><a href="https://doc.rust-lang.org/core/index.html"><code>core</code></a>: Usually this is not necessary, because <code>core</code> is automatically
imported, unless the crate is marked with <a href="https://github.com/rust-lang/rust/issues/29639"><code>#![no_core]</code></a>. For
example, some of the internal crates used by the standard library itself
need this.</li>
<li><a href="https://doc.rust-lang.org/proc_macro/index.html"><code>proc_macro</code></a>: This is automatically imported by Cargo if it is a
proc-macro crate starting in 1.42. <code>extern crate proc_macro;</code> would be
needed if you want to support older releases, or if using another build tool
that does not pass the appropriate <code>--extern</code> flags to <code>rustc</code>.</li>
<li><a href="https://doc.rust-lang.org/alloc/index.html"><code>alloc</code></a>: Items in the <code>alloc</code> crate are usually accessed via re-exports in
the <code>std</code> crate. If you are working with a <code>no_std</code> crate that supports
allocation, then you may need to explicitly import <code>alloc</code>.</li>
<li><a href="https://doc.rust-lang.org/test/index.html"><code>test</code></a>: This is only available on the <a href="https://doc.rust-jp.rs/book-ja/appendix-07-nightly-rust.html">nightly channel</a>, and is usually
only used for the unstable benchmark support.</li>
</ul>
<!--
[`alloc`]: ../../alloc/index.html
[`core`]: ../../core/index.html
[`proc_macro`]: ../../proc_macro/index.html
[`std`]: ../../std/index.html
[`test`]: ../../test/index.html
[nightly channel]: ../../book/appendix-07-nightly-rust.html
[no_core]: https://github.com/rust-lang/rust/issues/29639
[no_std]: ../../reference/names/preludes.html#the-no_std-attribute
-->
<h4><a class="header" href="#macros" id="macros">Macros</a></h4>
<p>One other use for <code>extern crate</code> was to import macros; that's no longer needed.
Macros may be imported with <code>use</code> like any other item. For example, the
following use of <code>extern crate</code>:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate bar;

fn main() {
    baz!();
}
</code></pre>
<p>Can be changed to something like the following:</p>
<pre><code class="language-rust ignore">use bar::baz;

fn main() {
    baz!();
}
</code></pre>
<h4><a class="header" href="#renaming-crates" id="renaming-crates">Renaming crates</a></h4>
<p>If you've been using <code>as</code> to rename your crate like this:</p>
<pre><code class="language-rust ignore">extern crate futures as f;

use f::Future;
</code></pre>
<p>then removing the <code>extern crate</code> line on its own won't work. You'll need to do this:</p>
<pre><code class="language-rust ignore">use futures as f;

use self::f::Future;
</code></pre>
<p>This change will need to happen in any module that uses <code>f</code>.</p>
<h3><a class="header" href="#the-crate-keyword-refers-to-the-current-crate" id="the-crate-keyword-refers-to-the-current-crate">The <code>crate</code> keyword refers to the current crate</a></h3>
<p>In <code>use</code> declarations and in other code, you can refer to the root of the
current crate with the <code>crate::</code> prefix. For instance, <code>crate::foo::bar</code> will
always refer to the name <code>bar</code> inside the module <code>foo</code>, from anywhere else in
the same crate.</p>
<p>The prefix <code>::</code> previously referred to either the crate root or an external
crate; it now unambiguously refers to an external crate. For instance,
<code>::foo::bar</code> always refers to the name <code>bar</code> inside the external crate <code>foo</code>.</p>
<h3><a class="header" href="#extern-crate-paths" id="extern-crate-paths">Extern crate paths</a></h3>
<p>Previously, using an external crate in a module without a <code>use</code> import
required a leading <code>::</code> on the path.</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate chrono;

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // but in a submodule it requires a leading :: if not imported with `use`
        let x = ::chrono::Utc::now();
    }
}
</code></pre>
<p>Now, extern crate names are in scope in the entire crate, including
submodules.</p>
<pre><code class="language-rust ignore">// Rust 2018

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // crates may be referenced directly, even in submodules
        let x = chrono::Utc::now();
    }
}
</code></pre>
<h3><a class="header" href="#no-more-modrs" id="no-more-modrs">No more <code>mod.rs</code></a></h3>
<p>In Rust 2015, if you have a submodule:</p>
<pre><code class="language-rust ignore">// This `mod` declaration looks for the `foo` module in
// `foo.rs` or `foo/mod.rs`.
mod foo;
</code></pre>
<p>It can live in <code>foo.rs</code> or <code>foo/mod.rs</code>. If it has submodules of its own, it
<em>must</em> be <code>foo/mod.rs</code>. So a <code>bar</code> submodule of <code>foo</code> would live at
<code>foo/bar.rs</code>.</p>
<p>In Rust 2018 the restriction that a module with submodules must be named
<code>mod.rs</code> is lifted. <code>foo.rs</code> can just be <code>foo.rs</code>,
and the submodule is still <code>foo/bar.rs</code>. This eliminates the special
name, and if you have a bunch of files open in your editor, you can clearly
see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>
<table>
  <thead>
    <tr>
      <th>Rust 2015</th>
      <th>Rust 2018</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
<pre>
.
├── lib.rs
└── foo/
    ├── mod.rs
    └── bar.rs
</pre>
    </td>
    <td>
<pre>
.
├── lib.rs
├── foo.rs
└── foo/
    └── bar.rs
</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><a class="header" href="#use-paths" id="use-paths"><code>use</code> paths</a></h3>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<p>Rust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust
2015, paths work differently in <code>use</code> declarations than they do elsewhere. In
particular, paths in <code>use</code> declarations would always start from the crate
root, while paths in other code implicitly started from the current scope.
Those differences didn't have any effect in the top-level module, which meant
that everything would seem straightforward until working on a project large
enough to have submodules.</p>
<p>In Rust 2018, paths in <code>use</code> declarations and in other code work the same way,
both in the top-level module and in any submodule. You can use a relative path
from the current scope, a path starting from an external crate name, or a path
starting with <code>crate</code>, <code>super</code>, or <code>self</code>.</p>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>will look exactly the same in Rust 2018, except that you can delete the <code>extern crate</code> line:</p>
<pre><code class="language-rust ignore">// Rust 2018

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>The same code will also work completely unmodified in a submodule:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;

    mod foo {
        pub struct Bar;
    }

    use foo::Bar;

    fn my_poll() -&gt; futures::Poll { ... }

    enum SomeEnum {
        V1(usize),
        V2(String),
    }

    fn func() {
        let five = std::sync::Arc::new(5);
        use SomeEnum::*;
        match ... {
            V1(i) =&gt; { ... }
            V2(s) =&gt; { ... }
        }
    }
}
</code></pre>
<p>This makes it easy to move code around in a project, and avoids introducing
additional complexity to multi-module projects.</p>
<p>If a path is ambiguous, such as if you have an external crate and a local
module or item with the same name, you'll get an error, and you'll need to
either rename one of the conflicting names or explicitly disambiguate the path.
To explicitly disambiguate a path, use <code>::name</code> for an external crate name, or
<code>self::name</code> for a local module or item.</p>
<h1><a class="header" href="#anonymous-trait-function-parameters-deprecated" id="anonymous-trait-function-parameters-deprecated">Anonymous trait function parameters deprecated</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns">Trait function parameters</a> may use any irrefutable pattern when the function has a body.</li>
</ul>
<h2><a class="header" href="#details" id="details">Details</a></h2>
<p>In accordance with RFC <a href="https://github.com/rust-lang/rfcs/pull/1685">#1685</a>,
parameters in trait method declarations are no longer allowed to be anonymous.</p>
<p>For example, in the 2015 edition, this was allowed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, u8);
}
<span class="boring">}
</span></code></pre></pre>
<p>In the 2018 edition, all parameters must be given an argument name  (even if it's just
<code>_</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, baz: u8);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#new-keywords" id="new-keywords">New keywords</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<ul>
<li><code>dyn</code> is a <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keyword</a>, in 2015 it is a <a href="https://doc.rust-lang.org/reference/keywords.html#weak-keywords">weak keyword</a>.</li>
<li><code>async</code> and <code>await</code> are <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keywords</a>.</li>
<li><code>try</code> is a <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved keyword</a>.</li>
</ul>
<h2><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h2>
<h3><a class="header" href="#dyn-trait-for-trait-objects" id="dyn-trait-for-trait-objects"><code>dyn Trait</code> for trait objects</a></h3>
<p>The <code>dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<p>And so on. In code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

// old
fn function1() -&gt; Box&lt;Trait&gt; {
<span class="boring">unimplemented!()
</span>}

// new
fn function2() -&gt; Box&lt;dyn Trait&gt; {
<span class="boring">unimplemented!()
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>That's it!</p>
<h4><a class="header" href="#why" id="why">Why?</a></h4>
<p>Using just the trait name for trait objects turned out to be a bad decision.
The current syntax is often ambiguous and confusing, even to veterans,
and favors a feature that is not more frequently used than its alternatives,
is sometimes slower, and often cannot be used at all when its alternatives can.</p>
<p>Furthermore, with <code>impl Trait</code> arriving, &quot;<code>impl Trait</code> vs <code>dyn Trait</code>&quot; is much
more symmetric, and therefore a bit nicer, than &quot;<code>impl Trait</code> vs <code>Trait</code>&quot;.
<code>impl Trait</code> is explained <a href="https://doc.rust-jp.rs/rust-by-example-ja/rust-by-example/trait/impl_trait.html">here</a>.</p>
<p>In the new edition, you should therefore prefer <code>dyn Trait</code> to just <code>Trait</code>
where you need a trait object.</p>
<!--
[impl-trait]: ../../rust-by-example/trait/impl_trait.html
-->
<h3><a class="header" href="#async-and-await" id="async-and-await"><code>async</code> and <code>await</code></a></h3>
<p>These keywords are reserved to implement the async-await feature of Rust, which was ultimately <a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">released to stable in 1.39.0</a>.</p>
<h3><a class="header" href="#try-keyword" id="try-keyword"><code>try</code> keyword</a></h3>
<p>The <code>try</code> keyword is reserved for use in <code>try</code> blocks, which have not (as of this writing) been stabilized (<a href="https://github.com/rust-lang/rust/issues/31436">tracking issue</a>)</p>
<h1><a class="header" href="#method-dispatch-for-raw-pointers-to-inference-variables" id="method-dispatch-for-raw-pointers-to-inference-variables">Method dispatch for raw pointers to inference variables</a></h1>
<h2><a class="header" href="#summary-3" id="summary-3">Summary</a></h2>
<ul>
<li>The <a href="https://github.com/rust-lang/rust/issues/46906"><code>tyvar_behind_raw_pointer</code></a> lint is now a hard error.</li>
</ul>
<h2><a class="header" href="#details-1" id="details-1">Details</a></h2>
<p>See Rust issue <a href="https://github.com/rust-lang/rust/issues/46906">#46906</a> for details.</p>
<h1><a class="header" href="#cargo-changes" id="cargo-changes">Cargo changes</a></h1>
<h2><a class="header" href="#summary-4" id="summary-4">Summary</a></h2>
<ul>
<li>If there is a target definition in a <code>Cargo.toml</code> manifest, it no longer
automatically disables automatic discovery of other targets.</li>
<li>Target paths of the form <code>src/{target_name}.rs</code> are no longer inferred for
targets where the <code>path</code> field is not set.</li>
<li><code>cargo install</code> for the current directory is no longer allowed, you must
specify <code>cargo install --path .</code> to install the current package.</li>
</ul>
<!--
# The Next Edition
-->
<h1><a class="header" href="#rust-2018以降の変更" id="rust-2018以降の変更">Rust 2018以降の変更</a></h1>
<!--
We have not decided if and when the next edition will ship; there is talk of
a 2021 edition to keep up the three-year schedule, but that has not been
formally decided.
-->
<!--
Until we do, this section keeps track of changes that landed after Rust 2018.
-->
<p>このセクションではRust 2018以降に導入された変更点を説明します。</p>
<blockquote>
<p>訳注：このセクションは、英語版に以前あった「Next Edition」セクションの内容をベースにしています（英語版では現在は削除されています）</p>
<p>本書（和訳版）でも、次の「<a href="rust-post-2018/../rust-2021/index.html">Rust 2021</a>」セクションの翻訳作業が終わったら、このセクションを削除する予定です。</p>
</blockquote>
<!--
# The dbg! macro
-->
<h1><a class="header" href="#dbg-マクロ" id="dbg-マクロ">dbg! マクロ</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
The `dbg!` macro provides a nicer experience for debugging than `println!`:
-->
<p><code>dbg!</code>マクロは <code>println!</code>よりも、より良いデバッグ体験を提供します。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    dbg!(x);
}
</code></pre></pre>
<!--
If you run this program, you'll see:
-->
<p>このプログラムを実行すると、次の出力が表示されます。</p>
<pre><code class="language-text">[src/main.rs:4] x = 5
</code></pre>
<!--
You get the file and line number of where this was invoked, as well as the
name and value. Additionally, `println!` prints to the standard output, so you
really should be using `eprintln!` to print to standard error. `dbg!` does the
right thing and goes to stderr.
-->
<p>これを見ると、このマクロが呼ばれたソースコードファイル名、行番号とともに、変数名とその値が表示されているのがわかります。
さらに、<code>println!</code>は標準出力に出力するので、標準エラーに出力するためには<code>eprintln!</code>を使う必要がありますが、<code>dbg!</code>は正しく標準エラーに出力を行います。</p>
<!--
It even works in more complex circumstances. Consider this factorial example:
-->
<p><code>dbg!</code>マクロは、より複雑な状況でも動作します。以下の階乗の例を考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u32) -&gt; u32 {
    if n &lt;= 1 {
        n
    } else {
        n * factorial(n - 1)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
If we wanted to debug this, we might write it like this with `eprintln!`:
-->
<p>これをデバッグしたい場合、<code>eprintln!</code>を使ってこのように書くかも知れません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u32) -&gt; u32 {
    eprintln!(&quot;n: {}&quot;, n);

    if n &lt;= 1 {
        eprintln!(&quot;n &lt;= 1&quot;);

        n
    } else {
        let n = n * factorial(n - 1);

        eprintln!(&quot;n: {}&quot;, n);

        n
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We want to log `n` on each iteration, as well as have some kind of context
for each of the branches. We see this output for `factorial(4)`:
 -->
<p>ここでは、各反復で<code>n</code>の値と、場合分けのコンテキストを記録したいのですが、 <code>factorial(4)</code>を実行すると以下の出力が得られます。</p>
<pre><code class="language-text">n: 4
n: 3
n: 2
n: 1
n &lt;= 1
n: 2
n: 6
n: 24
</code></pre>
<!--
This is servicable, but not particularly great. Maybe we could work on how we
print out the context to make it more clear, but now we're not debugging our
code, we're figuring out how to make our debugging code better.
-->
<p>これは使えなくはないですが、特別に良いということでもありません。
コンテキストをより明確に表示するのに工夫することはできるでしょうが、ここではコードのデバッグをしているのではなく、デバッグ用のコードをより良くする方法を探そうとしています。</p>
<!--
Consider this version using `dbg!`:
-->
<p><code>dbg!</code>を使ったこのバージョンを考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u32) -&gt; u32 {
    if dbg!(n &lt;= 1) {
        dbg!(1)
    } else {
        dbg!(n * factorial(n - 1))
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We simply wrap each of the various expressions we want to print with the macro. We get this output instead:
 -->
<p>ここでは、表示したい幾つかの式を単純にマクロで囲っています。
これを実行するとこのような出力が得られます。</p>
<pre><code class="language-text">[src/main.rs:3] n &lt;= 1 = false
[src/main.rs:3] n &lt;= 1 = false
[src/main.rs:3] n &lt;= 1 = false
[src/main.rs:3] n &lt;= 1 = true
[src/main.rs:4] 1 = 1
[src/main.rs:5] n * factorial(n - 1) = 2
[src/main.rs:5] n * factorial(n - 1) = 6
[src/main.rs:5] n * factorial(n - 1) = 24
[src/main.rs:11] factorial(4) = 24
</code></pre>
<!--
Because the `dbg!` macro returns the value of what it's debugging, instead of
`eprintln!` which returns `()`, we need to make no changes to the structure of
our code. Additionally, we have vastly more useful output.
-->
<p><code>eprintln!</code>は常に<code>()</code>を返しますが、<code>dbg!</code>マクロは与えられた式の値を返すので、コードの構成を変える必要がありません。
加えて、表示結果にとても役に立つ情報が含まれています。</p>
<!--
# No jemalloc by default
-->
<h1><a class="header" href="#デフォルトでjemallocを使わない" id="デフォルトでjemallocを使わない">デフォルトでjemallocを使わない</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
Long, long ago, Rust had a large, Erlang-like runtime. We chose to use
jemalloc instead of the system allocator, because it often improved
performance over the default system one. Over time, we shed more and more of
this runtime, and eventually almost all of it was removed, but jemalloc was
not. We didn't have a way to choose a custom allocator, and so we couldn't
really remove it without causing a regression for people who do need
jemalloc.
 -->
<p>遠い遠い昔、RustはErlang風のとても大きなランタイムを持っていました。
その際、性能面での改善が得られていたので、システムの標準のアロケータではなく、jemallocを使うという選択をしました。
それ以来、我々はランタイムの機能を徐々に削ぎ落とし、最終的にはほとんど何もなくなりましたが、jemallocは残されていました。
カスタムのアロケータを選ぶ方法がなく、jemallocを必要としている人に影響を与えることなくそれを削除することが出来なかったからです。</p>
<!--
Also, saying that jemalloc was always the default is a bit UNIX-centric, as
it was only the default on some platforms. Notably, the MSVC target on
Windows has shipped the system allocator for a long time.
-->
<p>さらに、jemallocは特定のプラットフォームでのみデフォルトなので、それが常にデフォルトだと言うのはややUnix偏重主義でしょう。
特にWindows上のMSVCターゲットは、長い間、システムのアロケータで出荷されています。</p>
<!--
While jemalloc usually has great performance, that's not always the case.
Additionally, it adds about 300kb to every Rust binary. We've also had a host
of other issues with jemalloc in the past. It has also felt a little strange
that a systems language does not default to the system's allocator.
-->
<p>jemallocは通常とても良い性能を出しますが、常にというわけではありません。
加えて、jemallocを使うとRustのすべてのバイナリーが300kb大きくなります。
そして、過去にはjemallocにまつわる問題が多くありました。
また、システム言語であるRustが、システムが提供するアロケータを使わないのは少し変だとも考えられていました。</p>
<!--
For all of these reasons, once Rust 1.28 shipped a way to choose a global
allocator, we started making plans to switch the default to the system
allocator, and allow you to use jemalloc via a crate. In Rust 1.32, we've
finally finished this work, and by default, you will get the system allocator
for your programs.
-->
<p>これらの理由により、Rust 1.28でグローバルアロケーターを選択できるようになってから、我々はシステムの提供するアロケータをデフォルトにして、jemallocはクレートを通じて使えるようにする計画を立て始めました。
Rust 1.32でこれが完成し、それぞれのプラットフォームでシステムが提供するアロケータがデフォルトで使われるようになりました。</p>
<!--
If you'd like to continue to use jemalloc, use the jemallocator crate. In
your Cargo.toml:
-->
<p>もしjemallocを使い続けたいのであれば、jemallocatorクレートを使ってください。
あなたのCargo.tomlに以下のように書き、</p>
<pre><code class="language-toml">jemallocator = &quot;0.1.8&quot;
</code></pre>
<!--
And in your crate root:
-->
<p>あなたのクレートのルートで以下のように書きます。</p>
<pre><code class="language-rust ignore">#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
</code></pre>
<!--
That's it! If you don't need jemalloc, it's not forced upon you, and if you
do need it, it's a few lines of code away.
-->
<p>これだけです。あなたがjemallocを必要としていなければ強制されませんし、もし必要であれば数行追加するだけです。</p>
<!--
# Uniform Paths
-->
<h1><a class="header" href="#統一的なパス" id="統一的なパス">統一的なパス</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
Rust 2018 added several improvements to the module system. We have one last
tweak landing in 1.32.0. Nicknamed "uniform paths", it permits previously
invalid import path statements to be resolved exactly the same way as
non-import paths. For example:
-->
<p>Rust 2018でモジュールシステムに幾つかの改善が加えられましたが、Rust 1.32.0で最終的な微調整の変更を一つ入れています。
「統一的なパス」と呼ばれるこの機能により、以前は不正だったインポートパス文を、インポート以外のパスと同じ様に解釈できるようになりました。例えば、以下の例を考えます。</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red,
    Green,
    Blue,
}

use Color::*;
<span class="boring">}
</span></code></pre></pre>
<!--
This code did not previously compile, as use statements had to start with
`super`, `self`, or `crate`. Now that the compiler supports uniform paths,
this code will work, and do what you probably expect: import the variants of
the Color enum defined above the `use` statement.
-->
<p>以前は、use文は<code>super</code>、<code>self</code>あるいは<code>crate</code>で始まらなければならなかったので、このコードはコンパイル出来ませんでした。
今ではコンパイラーが統一的なパスをサポートするようになり、このコードはあなたの想像通りの動作をします。
つまり、<code>use</code>文の上で宣言されているColor列挙型のヴァリアントをインポートします。</p>
<!--
# literal macro matcher
-->
<h1><a class="header" href="#リテラルマクロマッチャ" id="リテラルマクロマッチャ">リテラルマクロマッチャ</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
A new `literal` matcher was added for macros:
-->
<p>リテラル（<code>literal</code>）マッチャがマクロに付け加えられました。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! m {
    ($lt:literal) =&gt; {};
}

fn main() {
    m!(&quot;some string literal&quot;);
}
</code></pre></pre>
<!--
`literal` matches against literals of any type; string literals, numeric
literals, `char` literals.
-->
<p><code>literal</code>は、文字列リテラル、数値リテラル、文字リテラルなど、どんなタイプのリテラルにもマッチします。</p>
<!--
# ? operator in macros
-->
<h1><a class="header" href="#マクロ内の演算子" id="マクロ内の演算子">マクロ内の?演算子</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<!--
`macro_rules` macros can use `?`, like this:
-->
<p><code>macro_rules</code> マクロ内で、<code>?</code>演算子を以下のように使えます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! bar {
    ($(a)?) =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `?` will match zero or one repetitions of the pattern, similar to the
already-existing `*` for "zero or more" and `+` for "one or more."
-->
<p>既に利用可能な <code>*</code>演算子が「0回以上」、<code>+</code>演算子が「1回以上」の繰り返しパターンを表すのと同様に、<code>?</code>演算子は0もしくは1回のパターンを表します。</p>
<h1><a class="header" href="#const-fn" id="const-fn"><code>const fn</code></a></h1>
<!--
Initially added: ![Minimum Rust version: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" />で最初に導入されました。</p>
<!--
Expanded in many releases, see each aspect below for more details.
-->
<p>そしてその後のリリースで何度か拡張されています。詳細は以下を確認してください。</p>
<!--
A `const fn` allows you to execute code in a "const context." For example:
-->
<p><code>const fn</code>によりコードを「constコンテキスト」で実行することができます(訳注：つまり、コンパイル時に評価されます)。例を示します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn five() -&gt; i32 {
    5
}

const FIVE: i32 = five();
<span class="boring">}
</span></code></pre></pre>
<!--
You cannot execute arbitrary code; the reasons why boil down to "you can
destroy the type system." The details are a bit too much to put here, but the
core idea is that `const fn` started off allowing the absolutely minimal
subset of the language, and has slowly added more abilities over time.
Therefore, while you can create a `const fn` in Rust 1.31, you cannot do much
with it. This is why we didn't add `const fn` to the Rust 2018 section; it
truly didn't become useful until after the release of the 2018 edition. This
means that if you read this document top to bottom, the earlier versions may
describe restrictions that are relaxed in later versions.

-->
<p>const fnでは任意のコードを実行することは出来ません。
というのは、簡単に言うと型システムを壊してしまうことになるからです。
詳細はここでは述べませんが、<code>const fn</code>では最小限の言語サブセットのみを使えるところからスタートし、徐々に出来ることを増やしていく、というのが基本的な考え方です。
したがって、導入当初のRust 1.31では <code>const fn</code>関数を作ることは出来ましたが、実際に出来ることはほとんどありませんでした。
これが、<code>const fn</code>をRust 2018のセクションに含めなかった理由なのですが、実際、Rust 2018エディションのリリース時にはあまり使い物になりませんでした。
もしあなたがこのドキュメントを最初から最後まで読んだとすると、以前のバージョンで制約とされていた部分がその後のバージョンで緩和されていることがわかるでしょう。</p>
<!--
Additionally, this has allowed more and more of the standard library to be
made `const`, we won't put all of those changes here, but you should know
that it is becoming more `const` over time.
-->
<p>さらに付け加えると、<code>const fn</code>で利用できる表記方が増えるに従って、標準ライブラリの機能が<code>const</code>化されていっています。
ここではその変更の全てを述べることはしませんが、時とともに <code>const</code>化される部分が増えていくことは知っておいても良いでしょう。</p>
<!--
## Arithmetic and comparison operators on integers
-->
<h2><a class="header" href="#整数の算術演算および比較演算" id="整数の算術演算および比較演算">整数の算術演算および比較演算</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can do arithmetic on integer literals:
-->
<p>整数リテラルに対して算術演算をすることができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; i32 {
    5 + 6
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Many boolean operators
-->
<h2><a class="header" href="#多くのブーリアン演算" id="多くのブーリアン演算">多くのブーリアン演算</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can use boolean operators other than `&&` and `||`, because they short-circut evaluation:
-->
<p>ブーリアン演算のほとんどが使えます。
例外は<code>&amp;&amp;</code>と<code>||</code>で、これらは短絡評価を行うので使えなくなっています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn mask(val: u8) -&gt; u8 {
    let mask = 0x0f;

    mask &amp; val
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Constructing arrays, structs, enums, and tuples
-->
<h2><a class="header" href="#配列構造体列挙型タプルの生成" id="配列構造体列挙型タプルの生成">配列、構造体、列挙型、タプルの生成</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can create arrays, structs, enums, and tuples:
-->
<p>配列、構造体、列挙型、タプルを生成することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

enum Error {
    Incorrect,
    FileNotFound,
}

const fn foo() {
    let array = [1, 2, 3];

    let point = Point {
        x: 5,
        y: 10,
    };

    let error = Error::FileNotFound;

    let tuple = (1, 2, 3);
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Calls to other const fns
-->
<h2><a class="header" href="#他のconst関数の呼び出し" id="他のconst関数の呼び出し">他のconst関数の呼び出し</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can call `const fn` from a `const fn`:
-->
<p><code>const fn</code>から<code>const fn</code>を呼び出すことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; i32 {
    5
}

const fn bar() -&gt; i32 {
    foo()
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Index expressions on arrays and slices
-->
<h2><a class="header" href="#配列やスライスの添字式" id="配列やスライスの添字式">配列やスライスの添字式</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can index into an array or slice:
-->
<p>配列やスライスに添え字アクセスできます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; i32 {
    let array = [1, 2, 3];

    array[1]
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Field accesses on structs and tuples
-->
<h2><a class="header" href="#構造体やタプルのフィールドアクセス" id="構造体やタプルのフィールドアクセス">構造体やタプルのフィールドアクセス</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can access parts of a struct or tuple:
-->
<p>構造体やタプルの構成要素にアクセスできます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

const fn foo() {
    let point = Point {
        x: 5,
        y: 10,
    };

    let tuple = (1, 2, 3);

    point.x;
    tuple.0;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Reading from constants
-->
<h2><a class="header" href="#定数読み出し" id="定数読み出し">定数読み出し</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can read from a constant:
-->
<p>定数の値を読み出せます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: i32 = 5;

const fn foo() -&gt; i32 {
    FOO
}
<span class="boring">}
</span></code></pre></pre>
<!--
Note that this is *only* `const`, not `static`.
-->
<p>読み出せるのは <code>const</code>指定された定数<em>のみ</em>で、<code>static</code>指定された変数は読み出せません。</p>
<!--
## & and * of references
-->
<h2><a class="header" href="#参照の--と-" id="参照の--と-">参照の &amp; と *</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You can create and de-reference references:
-->
<p>参照を作ったり、参照外しをすることができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo(r: &amp;i32) {
    *r;

    &amp;5;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Casts, except for raw pointer to integer casts
-->
<h2><a class="header" href="#キャストただし生ポインタから整数へのキャストは除く" id="キャストただし生ポインタから整数へのキャストは除く">キャスト。ただし生ポインタから整数へのキャストは除く</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<!--
You may cast things, except for raw pointers may not be casted to an integer:
-->
<p>キャストができます。
例外は生ポインタから整数へのキャスト。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() {
    let x: usize = 5;

    x as i32;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Irrefutable destructuring patterns
-->
<h2><a class="header" href="#論駁不可能な分配パターン" id="論駁不可能な分配パターン">論駁不可能な分配パターン</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can use irrefutable patterns that destructure values. For example:
-->
<p>論駁不可能なパターンで値を分配することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo((x, y): (u8, u8)) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `foo` destructures the tuple into `x` and `y`. `if let` is another
place that uses irrefutable patterns.
-->
<p>ここで、<code>foo</code>はタプルの値を<code>x</code>と<code>y</code>に分配します。
<code>if let</code>でも同様に論駁不可能なパターンを使います。</p>
<!--
## `let` bindings
-->
<h2><a class="header" href="#let-束縛" id="let-束縛"><code>let</code> 束縛</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can use both mutable and immutable `let` bindings:
-->
<p>ミュータブルとイミュータブルの双方の<code>let</code>束縛を使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() {
    let x = 5;
    let mut y = 10;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Assignment
-->
<h2><a class="header" href="#代入" id="代入">代入</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can use assignment and assignment operators:
-->
<p>代入と代入演算子を使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() {
    let mut x = 5;
    x = 10;
}
<span class="boring">}
</span></code></pre></pre>
<!--
## Calling `unsafe fn`
-->
<h2><a class="header" href="#unsafe-fn-の呼び出し" id="unsafe-fn-の呼び出し"><code>unsafe fn</code> の呼び出し</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
You can call an `unsafe fn` inside a `const fn`:
-->
<p><code>const fn</code>の中で<code>unsafe fn</code>を呼び出すことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const unsafe fn foo() -&gt; i32 { 5 }

const fn bar() -&gt; i32 {
    unsafe { foo() }
}
<span class="boring">}
</span></code></pre></pre>
<!--
# Pinning
-->
<h1><a class="header" href="#ピン留め" id="ピン留め">ピン留め</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.33-brightgreen.svg" alt="Minimum Rust version: 1.33" /></p>
<!--
Rust 1.33 introduced a new concept, implemented as two types: 
-->
<p>Rust 1.33で新しい概念が導入され、二つの型で実装されました。</p>
<!--
* [`Pin<P>`](https://doc.rust-lang.org/std/pin/struct.Pin.html), a wrapper
  around a kind of pointer which makes that pointer "pin" its value in place,
  preventing the value referenced by that pointer from being moved.
* [`Unpin`](https://doc.rust-lang.org/std/marker/trait.Unpin.html), types that
  are safe to be moved, even if they're pinned.
  -->
<ul>
<li><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin&lt;P&gt;</code></a> ポインタ的なモノを包むラッパで、その値が動かないように「ピン留め」します。
それにより、そのポインタにより参照されている値がムーブされるのを防ぎます。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html"><code>Unpin</code></a> ピン留めされていても安全にムーブできる型です。</li>
</ul>
<!--
Most users will not interact with pinning directly, and so we won't explain
more here. For the details, see the [documentation for
`std::pin`](https://doc.rust-lang.org/std/pin/index.html).
-->
<p>ほとんどのユーザはピン留めを直接扱うことは無いと思うので、これ以上の説明は控えます。
より詳細を知りたければ<a href="https://doc.rust-lang.org/std/pin/index.html"><code>std::pin</code>のドキュメンテーション</a>を見てください。</p>
<!--
What *is* useful to know about pinning is that it's a pre-requisite for
`async`/`await`. Folks who write async libraries may need to learn about
pinning, but folks using them generally shouldn't need to interact with this
feature at all.
-->
<p>ピン留めは<code>async</code> / <code>await</code>の前提条件になっているということは知っておくと良いでしょう。
非同期のライブラリを作成する人はピン留めを学んでおく必要があるかも知れませんが、そのライブラリを使うだけの人はこの機能に直接触れることは無いでしょう。</p>
<!--
# No more FnBox
-->
<h1><a class="header" href="#fnboxは不要に" id="fnboxは不要に">FnBoxは不要に</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.35-brightgreen.svg" alt="Minimum Rust version: 1.35" /></p>
<!--
The book used to have this code in Chapter 20, section 2:
-->
<p>かつて、この本の20章2節には以下のコードがありました。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;dyn FnBox + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<!--
Here, we define a new trait called `FnBox`, and then implement it for all
`FnOnce` closures. All the implementation does is call the closure. These
sorts of hacks were needed because a `Box<dyn FnOnce>` didn't implement
`FnOnce`. This was true for all three posibilities:
-->
<p>ここで、<code>FnBox</code>という新しいトレイトを定義し、全ての<code>FnOnce</code>クロージャに対して実装をしています。
そして全ての実装がクロージャを呼び出します。
このハックは、<code>Box&lt;dyn FnOnce&gt;</code> が<code>FnOnce</code>を実装していなかったので必要でした。
そしてこれは以下の3つのパターンで必要でした。</p>
<!--
* `Box<dyn Fn>` and `Fn`
* `Box<dyn FnMut>` and `FnMut`
* `Box<dyn FnOnce>` and `FnOnce`
-->
<ul>
<li><code>Box&lt;dyn Fn&gt;</code> と <code>Fn</code></li>
<li><code>Box&lt;dyn FnMut&gt;</code> と <code>FnMut</code></li>
<li><code>Box&lt;dyn FnOnce&gt;</code> と <code>FnOnce</code></li>
</ul>
<!--
However, as of Rust 1.35, these traits are implemented for these types,
and so the `FnBox` trick is no longer required. In the latest version of
the book, the `Job` type looks like this:
-->
<p>しかし、Rust 1.35からこれらのトレイトがこれらの型に実装されたので、<code>FnBox</code>トリックは必要なくなりました。
この本の最新版では<code>Job</code>型はこのようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<!--
No need for all that other code.
-->
<p>これ以外のコードは不要です。</p>
<!--
# Alternative Cargo registries
-->
<h1><a class="header" href="#cargoレジストリが選択できるように" id="cargoレジストリが選択できるように">Cargoレジストリが選択できるように</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.34](https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg" alt="Minimum Rust version: 1.34" />で最初に導入されました。</p>
<!--
For various reasons, you may not want to publish code to crates.io, but you
may want to share it with others. For example, maybe your company writes Rust
code that's not open source, but you'd still like to use these internal
packages.
-->
<p>自分のコードを他の人とシェアしたいけど、何らかの理由でcrates.ioには公開したくないということがあるかも知れません。
例えば、あなたの会社ではオープンソースではないRustのコードを書いていて、でもその内部パッケージを使いたいという場合です。</p>
<!--
Cargo supports alternative registries by settings in `.cargo/config`:
-->
<p>Cargoは<code>.cargo/config</code>に設定を入れることで別のレジストリをサポートします。</p>
<pre><code class="language-toml">[registries]
my-registry = { index = &quot;https://my-intranet:7878/git/index&quot; }
</code></pre>
<!--
When you want to depend on a package from another registry, you add that
in to your `Cargo.toml`:
-->
<p>そして、別のレジストリのパッケージに依存したい時は、<code>Cargo.toml</code>にそれを追加します。</p>
<pre><code class="language-toml">[dependencies]
other-crate = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot; }
</code></pre>
<!--
To learn more, check out the [registries section of the Cargo
book](https://doc.rust-lang.org/nightly/cargo/reference/registries.html).
-->
<p>詳しく知りたい場合は、<a href="https://doc.rust-lang.org/nightly/cargo/reference/registries.html">Cargoブックのレジストリのセクション</a>を確認してみてください。</p>
<!--
# TryFrom and TryInto
-->
<h1><a class="header" href="#tryfromとtryinto" id="tryfromとtryinto">TryFromとTryInto</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.34](https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.34-brightgreen.svg" alt="Minimum Rust version: 1.34" />で最初に導入されました。</p>
<!--
The [`TryFrom`](../../std/convert/trait.TryFrom.html) and
[`TryInto`](../../std/convert/trait.TryInto.html) traits are like the
[`From`](../../std/convert/trait.From.html) and
[`Into`](../../std/convert/trait.Into.html) traits, except that they return a
result, meaning that they may fail.
-->
<p><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>と<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a>トレイトは<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>と<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトと似ていますが、<code>Result</code>型を返すという点で異なっています。
つまり、これらの呼び出しは失敗することがあります。</p>
<!--
For example, the `from_be_bytes` and related methods on integer types take
arrays, but data is often read in via slices. Converting between slices and
arrays is tedious to do manually. With the new traits, it can be done inline
with `.try_into()`:
-->
<p>例えば、整数型の<code>from_be_bytes</code>や関連するメソッドは配列を引数に取りますが、そのデータはスライスから読み込まれるということがよくあります。スライスから配列への変換は手動でやると退屈なものです。
このトレイトを使えば、<code>try_into()</code>でインラインでできます。</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryInto;
<span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">let slice = &amp;[1, 2, 3, 4][..];
</span>let num = u32::from_be_bytes(slice.try_into()?);
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<!--
# The Future trait
-->
<h1><a class="header" href="#futureトレイト" id="futureトレイト">Futureトレイト</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.36](https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" />で最初に導入されました。</p>
<!--
In Rust 1.36.0 the long awaited [`Future`] trait has been stabilized!
-->
<p>Rust 1.36.0で長い間、待たれていた<a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>トレイトが安定化されました。</p>
<!--
TODO: this will probably be folded into a larger async section once we're
closer to the next edition.
-->
<p>TODO: 次のエディションに近づいたら、このページはおそらく大きな非同期セクションの中に織り込まれるでしょう。</p>
<!--
# The alloc crate
-->
<h1><a class="header" href="#allocクレート" id="allocクレート">allocクレート</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.36](https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" />で最初に導入されました。</p>
<!--
Before 1.36.0, the standard library consisted of the crates `std`, `core`, and `proc_macro`.
The `core` crate provided core functionality such as `Iterator` and `Copy`
and could be used in `#![no_std]` environments since it did not impose any requirements.
Meanwhile, the `std` crate provided types like `Box<T>` and OS functionality
but required a global allocator and other OS capabilities in return.
-->
<p>1.36.0以前は、 標準ライブラリは<code>std</code>、<code>core</code>、<code>proc_macro</code>クレートで構成されていました。
<code>core</code>クレートは<code>Iterator</code>や<code>Copy</code>のような主要機能を提供し、何も前提条件がなかったので<code>#![no_std]</code>環境で使うことができました。
一方、<code>std</code>クレートは<code>Box&lt;T&gt;</code>のような型やOSの機能を提供していましたが、その代わりにグローバルアロケータやその他のOSの機能を必要としていました。</p>
<!--
Starting with Rust 1.36.0, the parts of `std` that depend on a global allocator, e.g. `Vec<T>`,
are now available in the `alloc` crate. The `std` crate then re-exports these parts.
While `#![no_std]` *binaries* using `alloc` still require nightly Rust,
`#![no_std]` *library* crates can use the `alloc` crate in stable Rust.
Meanwhile, normal binaries, without `#![no_std]`, can depend on such library crates.
We hope this will facilitate the development of a `#![no_std]` compatible ecosystem of libraries
prior to stabilizing support for `#![no_std]` binaries using `alloc`.
-->
<p>Rust 1.36.0,から、<code>std</code>の中で、<code>Vec&lt;T&gt;</code>のようなグローバルアロケータに依存している部分は<code>alloc</code>クレートで提供されるようになりました。
<code>std</code>クレートはこれらを再公開します。
<code>alloc</code>を使う<code>#![no_std]</code>の<em>バイナリ</em>はまだnightly版のRustを必要としますが、<code>#![no_std]</code><em>ライブラリ</em>クレートは安定版のRustで<code>alloc</code>クレートを使うことができます。
一方で、<code>#![no_std]</code>ではない通常のバイナリはそのようなライブラリクレートに依存することが可能です。
これにより、<code>alloc</code>を使う<code>#![no_std]</code>バイナリのサポートが安定化する前に、<code>#![no_std]</code>互換のライブラリエコシステムの開発が進むことを期待しています。</p>
<!--
If you are the maintainer of a library that only relies on some allocation primitives to function,
consider making your library `#[no_std]` compatible by using the following at the top of your `lib.rs` file:
-->
<p>もしあなたが幾つかのアロケーションプリミティブのみに依存するライブラリのメンテナだったら、以下をあなたの<code>lib.rs</code>の先頭に入れて、<code>#[no_std]</code>互換にすることを検討してみてください。</p>
<pre><code class="language-rust ignore">#![no_std]

extern crate alloc;

use alloc::vec::Vec;
</code></pre>
<h1><a class="header" href="#maybeuninit" id="maybeuninit">MaybeUninit</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.36](https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" />で最初に導入されました。</p>
<!--
In previous releases of Rust, the [`mem::uninitialized`] function has allowed
you to bypass Rust's initialization checks by pretending that you've
initialized a value at type `T` without doing anything. One of the main uses
of this function has been to lazily allocate arrays.
-->
<p>以前のリリースのRustでは、<a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>関数により、何もせずに型Tの値を初期化したように見せかけて、Rustの初期化チェックをバイパスすることができました。
この関数の主要な使い道の一つは配列の遅延アロケートでした。</p>
<!--
However, [`mem::uninitialized`] is an incredibly dangerous operation that
essentially cannot be used correctly as the Rust compiler assumes that values
are properly initialized. For example, calling `mem::uninitialized::<bool>()`
causes *instantaneous __undefined behavior__* as, from Rust's point of view,
the uninitialized bits are neither `0` (for `false`) nor `1` (for `true`) -
the only two allowed bit patterns for `bool`.
-->
<p>しかし、Rustコンパイラは値が正しく初期化されることを想定しているので、<a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>関数は、本質的に正しく使うことができない、とても危険な操作です。
例えば、<code>mem::uninitialized::&lt;bool&gt;()</code>の呼び出しは<em>即時の__未定義動作__</em> を引き起こします。
なぜならば、Rustの視点からは、初期化されていないビットは<code>bool</code>の取り得る二つの値である、<code>0</code> (<code>false</code>) でも <code>1</code> (<code>true</code>) でもないからです。</p>
<!--
To remedy this situation, in Rust 1.36.0, the type [`MaybeUninit<T>`] has
been stabilized. The Rust compiler will understand that it should not assume
that a [`MaybeUninit<T>`] is a properly initialized `T`. Therefore, you can
do gradual initialization more safely and eventually use `.assume_init()`
once you are certain that `maybe_t: MaybeUninit<T>` contains an initialized
`T`.
-->
<p>この状況を是正するために、Rust 1.36.0で<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>型が安定化されました。
Rustコンパイラは、<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>は<code>T</code>が正しく初期化されると仮定できないことを理解しています。
したがって、段階的な初期化をより安全に行うことができ、<code>maybe_t: MaybeUninit&lt;T&gt;</code>が初期化された<code>T</code>を含んでいることが確実になったら、 <code>.assume_init()</code>を呼び出します。</p>
<!--
As [`MaybeUninit<T>`] is the safer alternative, starting with Rust 1.39, the
function [`mem::uninitialized`] will be deprecated.
-->
<p><a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>はより安全な代替手段であるため、Rust 1.39から、<a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>関数は非推奨となります。</p>
<h1><a class="header" href="#cargo-vendor" id="cargo-vendor">cargo vendor</a></h1>
<!--
Initially added: ![Minimum Rust version: 1.37](https://img.shields.io/badge/Minimum%20Rust%20Version-1.37-brightgreen.svg)
-->
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.37-brightgreen.svg" alt="Minimum Rust version: 1.37" />で最初に導入されました。</p>
<!--
After being available [as a separate crate][vendor-crate] for years, the `cargo vendor` command is now integrated directly into Cargo. The command fetches all your project's dependencies unpacking them into the `vendor/` directory, and shows the configuration snippet required to use the vendored code during builds.
-->
<p>長年、<a href="https://crates.io/crates/cargo-vendor">別のクレート</a>として提供されてきたのちに、<code>cargo vendor</code>コマンドがCargoに直接統合されました。
このコマンドはあなたのプロジェクトの依存関係を全て取ってきて、<code>vendor/</code>ディレクトリの下に展開します。
そして、ビルド時にベンダーコードを使うために必要なコンフィグレーションの断片表示します。</p>
<!--
There are multiple cases where `cargo vendor` is already used in production: the Rust compiler `rustc` uses it to ship all its dependencies in release tarballs, and projects with monorepos use it to commit the dependencies' code in source control.
-->
<p><code>cargo vendor</code>が既に使われている例が幾つかあります。
<code>rustc</code>コンパイラは全ての依存ライブラリをリリースアーカイブに入れるのに使い、モノリポのプロジェクトは依存コードをソースコード管理ツールにコミットするのに使っています。</p>
<h1><a class="header" href="#rust-2021" id="rust-2021">Rust 2021</a></h1>
<!--
| Info | |
| --- | --- |
| RFC | [#3085](https://github.com/rust-lang/rfcs/pull/3085) |
| Release version | 1.56.0 |
-->
<table><thead><tr><th>情報</th><th></th></tr></thead><tbody>
<tr><td>RFC</td><td><a href="https://github.com/rust-lang/rfcs/pull/3085">#3085</a></td></tr>
<tr><td>リリースバージョン</td><td>1.56.0</td></tr>
</tbody></table>
<!--
The Rust 2021 Edition contains several changes that bring new capabilities and more consistency to the language,
and opens up room for expansion in the future.
The following chapters dive into the details of each change,
and they include guidance on migrating your existing code.
-->
<p>Rust 2021 エディションでは、新機能を追加し、言語をより一貫したものにして、
さらに将来の拡張性の余地を広げるための、いくつかの変更がなされています。
以下の章ではこれらの変更の詳細を見ていくと同時に、
既存のコードを移行するためのガイドも示していきます。</p>
<h1><a class="header" href="#additions-to-the-prelude" id="additions-to-the-prelude">Additions to the prelude</a></h1>
<h2><a class="header" href="#summary-5" id="summary-5">Summary</a></h2>
<ul>
<li>The <code>TryInto</code>, <code>TryFrom</code> and <code>FromIterator</code> traits are now part of the prelude.</li>
<li>This might make calls to trait methods ambiguous which could make some code fail to compile.</li>
</ul>
<h2><a class="header" href="#details-2" id="details-2">Details</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/std/prelude/index.html">prelude of the standard library</a>
is the module containing everything that is automatically imported in every module.
It contains commonly used items such as <code>Option</code>, <code>Vec</code>, <code>drop</code>, and <code>Clone</code>.</p>
<p>The Rust compiler prioritizes any manually imported items over those
from the prelude, to make sure additions to the prelude will not break any existing code.
For example, if you have a crate or module called <code>example</code> containing a <code>pub struct Option;</code>,
then <code>use example::*;</code> will make <code>Option</code> unambiguously refer to the one from <code>example</code>;
not the one from the standard library.</p>
<p>However, adding a <em>trait</em> to the prelude can break existing code in a subtle way.
For example, a call to <code>x.try_into()</code> which comes from a <code>MyTryInto</code> trait might fail 
to compile if <code>std</code>'s <code>TryInto</code> is also imported, because the call to <code>try_into</code> is now 
ambiguous and could come from either trait. This is the reason we haven't added <code>TryInto</code> 
to the prelude yet, since there is a lot of code that would break this way.</p>
<p>As a solution, Rust 2021 will use a new prelude.
It's identical to the current one, except for three new additions:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html"><code>std::convert::TryInto</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html"><code>std::convert::TryFrom</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html"><code>std::iter::FromIterator</code></a></li>
</ul>
<p>The tracking issue <a href="https://github.com/rust-lang/rust/issues/85684">can be found here</a>.</p>
<h2><a class="header" href="#migration" id="migration">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <code>rust_2021_prelude_collisions</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to have <code>rustfix</code> migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>The lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.</p>
<p>If you'd like to migrate your code manually or better understand what <code>rustfix</code> is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.</p>
<h3><a class="header" href="#migration-needed" id="migration-needed">Migration needed</a></h3>
<h4><a class="header" href="#conflicting-trait-methods" id="conflicting-trait-methods">Conflicting trait methods</a></h4>
<p>When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait&lt;A&gt; {
  // This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  
  fn from_iter(x: Option&lt;A&gt;);
}

impl&lt;T&gt; MyTrait&lt;()&gt; for Vec&lt;T&gt; {
  fn from_iter(_: Option&lt;()&gt;) {}
}

fn main() {
  // Vec&lt;T&gt; implements both `std::iter::FromIterator` and `MyTrait` 
  // If both traits are in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `from_iter` method to call
  &lt;Vec&lt;i32&gt;&gt;::from_iter(None);
}
</code></pre></pre>
<p>We can fix this by using fully qualified syntax:</p>
<pre><code class="language-rust ignore">fn main() {
  // Now it is clear which trait method we're referring to
  &lt;Vec&lt;i32&gt; as MyTrait&lt;()&gt;::from_iter(None);
}
</code></pre>
<h4><a class="header" href="#inherent-methods-on-dyn-trait-objects" id="inherent-methods-on-dyn-trait-objects">Inherent methods on <code>dyn Trait</code> objects</a></h4>
<p>Some users invoke methods on a <code>dyn Trait</code> value where the method name overlaps with a new prelude trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod submodule {
  pub trait MyTrait {
    // This has the same name as `TryInto::try_into`
    fn try_into(&amp;self) -&gt; Result&lt;u32, ()&gt;;
  }
}

// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`
fn bar(f: Box&lt;dyn submodule::MyTrait&gt;) {
  // If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `try_into` method to call
  f.try_into();
}
<span class="boring">}
</span></code></pre></pre>
<p>Unlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works 
as long as there is no trait in scope with a conflicting method name. When the <code>TryInto</code> trait is in scope (which is the case in Rust 2021),
this causes an ambiguity. Should the call be to <code>MyTrait::try_into</code> or <code>std::convert::TryInto::try_into</code>?</p>
<p>In these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that 
the <code>dyn Trait</code> method is chosen, versus the methods from the prelude trait. For example, turning <code>f.try_into()</code> above into <code>(&amp;*f).try_into()</code> 
ensures that we're calling <code>try_into</code> on the <code>dyn MyTrait</code> which can only refer to the <code>MyTrait::try_into</code> method.</p>
<h3><a class="header" href="#no-migration-needed" id="no-migration-needed">No migration needed</a></h3>
<h4><a class="header" href="#inherent-methods" id="inherent-methods">Inherent methods</a></h4>
<p>Many types define their own inherent methods with the same name as a trait method. For instance, below the struct <code>MyStruct</code> implements <code>from_iter</code> which shares the same name with the method from the trait <code>FromIterator</code> found in the standard library:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter::IntoIterator;

struct MyStruct {
  data: Vec&lt;u32&gt;
}

impl MyStruct {
  // This has the same name as `std::iter::FromIterator::from_iter`
  fn from_iter(iter: impl IntoIterator&lt;Item = u32&gt;) -&gt; Self {
    Self {
      data: iter.into_iter().collect()
    }
  }
}

impl std::iter::FromIterator&lt;u32&gt; for MyStruct {
    fn from_iter&lt;I: IntoIterator&lt;Item = u32&gt;&gt;(iter: I) -&gt; Self {
      Self {
        data: iter.into_iter().collect()
      }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Inherent methods always take precedent over trait methods so there's no need for any migration.</p>
<h3><a class="header" href="#implementation-reference" id="implementation-reference">Implementation Reference</a></h3>
<p>The lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:</p>
<ul>
<li>Is the call a <a href="https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls">fully-qualified call</a> or does it use <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">dot-call method syntax</a>?
<ul>
<li>This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. <code>&lt;Type as Trait&gt;::method</code>)</li>
</ul>
</li>
<li>Is this an <a href="https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations">inherent method</a> or <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations">a trait method</a>?
<ul>
<li>Inherent methods that take <code>self</code> will take priority over <code>TryInto::try_into</code> as inherent methods take priority over trait methods, but inherent methods that take <code>&amp;self</code> or <code>&amp;mut self</code> won't take priority due to requiring a auto-reference (while <code>TryInto::try_into</code> does not, as it takes <code>self</code>)</li>
</ul>
</li>
<li>Is the origin of this method from <code>core</code>/<code>std</code>? (As the traits can't have a collision with themselves)</li>
<li>Does the given type implement the trait it could have a collision against?</li>
<li>Is the method being called via dynamic dispatch? (i.e. is the <code>self</code> type <code>dyn Trait</code>)
<ul>
<li>If so, trait imports don't affect resolution, and no migration lint needs to occur</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#default-cargo-feature-resolver" id="default-cargo-feature-resolver">Default Cargo feature resolver</a></h1>
<h2><a class="header" href="#summary-6" id="summary-6">Summary</a></h2>
<ul>
<li><code>edition = &quot;2021&quot;</code> implies <code>resolver = &quot;2&quot;</code> in <code>Cargo.toml</code>.</li>
</ul>
<h2><a class="header" href="#details-3" id="details-3">Details</a></h2>
<p>Since Rust 1.51.0, Cargo has opt-in support for a <a href="https://doc.rust-lang.org/cargo/reference/resolver.html#feature-resolver-version-2">new feature resolver</a>
which can be activated with <code>resolver = &quot;2&quot;</code> in <code>Cargo.toml</code>.</p>
<p>Starting in Rust 2021, this will be the default.
That is, writing <code>edition = &quot;2021&quot;</code> in <code>Cargo.toml</code> will imply <code>resolver = &quot;2&quot;</code>.</p>
<p>The resolver is a global setting for a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">workspace</a>, and the setting is ignored in dependencies.
The setting is only honored for the top-level package of the workspace.
If you are using a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-manifest">virtual workspace</a>, you will still need to explicitly set the <a href="https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions"><code>resolver</code> field</a>
in the <code>[workspace]</code> definition if you want to opt-in to the new resolver.</p>
<p>The new feature resolver no longer merges all requested features for
crates that are depended on in multiple ways.
See <a href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver">the announcement of Rust 1.51</a> for details.</p>
<!--
[4]: ../../cargo/reference/resolver.html#feature-resolver-version-2
[5]: https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver
[workspace]: ../../cargo/reference/workspaces.html
[virtual workspace]: ../../cargo/reference/workspaces.html#virtual-manifest
[`resolver` field]: ../../cargo/reference/resolver.html#resolver-versions
-->
<h2><a class="header" href="#migration-1" id="migration-1">Migration</a></h2>
<p>There are no automated migration tools for updating for the new resolver.
For most projects, there are usually few or no changes as a result of updating.</p>
<p>When updating with <code>cargo fix --edition</code>, Cargo will display a report if the new resolver will build dependencies with different features.
It may look something like this:</p>
<blockquote>
<p>note: Switching to Edition 2021 will enable the use of the version 2 feature resolver in Cargo.
This may cause some dependencies to be built with fewer features enabled than previously.
More information about the resolver changes may be found at <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html">https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html</a><br>
When building the following dependencies, the given features will no longer be used:</p>
<pre><code class="language-text">  bstr v0.2.16: default, lazy_static, regex-automata, unicode
  libz-sys v1.1.3 (as host dependency): libc
</code></pre>
</blockquote>
<p>This lets you know that certain dependencies will no longer be built with the given features.</p>
<h3><a class="header" href="#build-failures" id="build-failures">Build failures</a></h3>
<p>There may be some circumstances where your project may not build correctly after the change.
If a dependency declaration in one package assumes that certain features are enabled in another, and those features are now disabled, it may fail to compile.</p>
<p>For example, let's say we have a dependency like this:</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
bstr = { version = &quot;0.2.16&quot;, default-features = false }
# ...
</code></pre>
<p>And somewhere in our dependency tree, another package has this:</p>
<pre><code class="language-toml"># Another package's Cargo.toml

[build-dependencies]
bstr = &quot;0.2.16&quot;
</code></pre>
<p>In our package, we've been using the <a href="https://docs.rs/bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks"><code>words_with_breaks</code></a> method from <code>bstr</code>, which requires <code>bstr</code>'s  &quot;unicode&quot; feature to be enabled.
This has historically worked because Cargo unified the features of <code>bstr</code> between the two packages.
However, after updating to Rust 2021, the new resolver will build <code>bstr</code> twice, once with the default features (as a build dependency), and once with no features (as our normal dependency).
Since <code>bstr</code> is now being built without the &quot;unicode&quot; feature, the <code>words_with_breaks</code> method doesn't exist, and the build will fail with an error that the method is missing.</p>
<p>The solution here is to ensure that the dependency is declared with the features you are actually using.
For example:</p>
<pre><code class="language-toml">[dependencies]
bstr = { version = &quot;0.2.16&quot;, default-features = false, features = [&quot;unicode&quot;] }
</code></pre>
<p>In some cases, this may be a problem with a third-party dependency that you don't have direct control over.
You can consider submitting a patch to that project to try to declare the correct set of features for the problematic dependency.
Alternatively, you can add features to any dependency from within your own <code>Cargo.toml</code> file.
For example, if the <code>bstr</code> example given above was declared in some third-party dependency, you can just copy the correct dependency declaration into your own project.
The features will be unified, as long as they match the unification rules of the new resolver. Those are:</p>
<ul>
<li>Features enabled on platform-specific dependencies for targets not currently being built are ignored.</li>
<li>Build-dependencies and proc-macros do not share features with normal dependencies.</li>
<li>Dev-dependencies do not activate features unless building a target that needs them (like tests or examples).</li>
</ul>
<p>A real-world example is using <a href="https://crates.io/crates/diesel"><code>diesel</code></a> and <a href="https://crates.io/crates/diesel_migrations"><code>diesel_migrations</code></a>.
These packages provide database support, and the database is selected using a feature, like this:</p>
<pre><code class="language-toml">[dependencies]
diesel = { version = &quot;1.4.7&quot;, features = [&quot;postgres&quot;] }
diesel_migrations = &quot;1.4.0&quot;
</code></pre>
<p>The problem is that <code>diesel_migrations</code> has an internal proc-macro which itself depends on <code>diesel</code>, and the proc-macro assumes its own copy of <code>diesel</code> has the same features enabled as the rest of the dependency graph.
After updating to the new resolver, it fails to build because now there are two copies of <code>diesel</code>, and the one built for the proc-macro is missing the &quot;postgres&quot; feature.</p>
<p>A solution here is to add <code>diesel</code> as a build-dependency with the required features, for example:</p>
<pre><code class="language-toml">[build-dependencies]
diesel = { version = &quot;1.4.7&quot;, features = [&quot;postgres&quot;] }
</code></pre>
<p>This causes Cargo to add &quot;postgres&quot; as a feature for host dependencies (proc-macros and build-dependencies).
Now, the <code>diesel_migrations</code> proc-macro will get the &quot;postgres&quot; feature enabled, and it will build correctly.</p>
<p>The 2.0 release of <code>diesel</code> (currently in development) does not have this problem as it has been restructured to not have this dependency requirement.</p>
<h3><a class="header" href="#exploring-features" id="exploring-features">Exploring features</a></h3>
<p>The <a href="https://doc.rust-lang.org/cargo/commands/cargo-tree.html"><code>cargo tree</code></a> command has had substantial improvements to help with the migration to the new resolver.
<code>cargo tree</code> can be used to explore the dependency graph, and to see which features are being enabled, and importantly <em>why</em> they are being enabled.</p>
<p>One option is to use the <code>--duplicates</code> flag (<code>-d</code> for short), which will tell you when a package is being built multiple times.
Taking the <code>bstr</code> example from earlier, we might see:</p>
<pre><code class="language-console">&gt; cargo tree -d
bstr v0.2.16
└── foo v0.1.0 (/MyProjects/foo)

bstr v0.2.16
[build-dependencies]
└── bar v0.1.0
    └── foo v0.1.0 (/MyProjects/foo)

</code></pre>
<p>This output tells us that <code>bstr</code> is built twice, and shows the chain of dependencies that led to its inclusion in both cases.</p>
<p>You can print which features each package is using with the <code>-f</code> flag, like this:</p>
<pre><code class="language-console">cargo tree -f '{p} {f}'
</code></pre>
<p>This tells Cargo to change the &quot;format&quot; of the output, where it will print both the package and the enabled features.</p>
<p>You can also use the <code>-e</code> flag to tell it which &quot;edges&quot; to display.
For example, <code>cargo tree -e features</code> will show in-between each dependency which features are being added by each dependency.
This option becomes more useful with the <code>-i</code> flag which can be used to &quot;invert&quot; the tree.
This allows you to see how features <em>flow</em> into a given dependency.
For example, let's say the dependency graph is large, and we're not quite sure who is depending on <code>bstr</code>, the following command will show that:</p>
<pre><code class="language-console">&gt; cargo tree -e features -i bstr
bstr v0.2.16
├── bstr feature &quot;default&quot;
│   [build-dependencies]
│   └── bar v0.1.0
│       └── bar feature &quot;default&quot;
│           └── foo v0.1.0 (/MyProjects/foo)
├── bstr feature &quot;lazy_static&quot;
│   └── bstr feature &quot;unicode&quot;
│       └── bstr feature &quot;default&quot; (*)
├── bstr feature &quot;regex-automata&quot;
│   └── bstr feature &quot;unicode&quot; (*)
├── bstr feature &quot;std&quot;
│   └── bstr feature &quot;default&quot; (*)
└── bstr feature &quot;unicode&quot; (*)
</code></pre>
<p>This snippet of output shows that the project <code>foo</code> depends on <code>bar</code> with the &quot;default&quot; feature.
Then, <code>bar</code> depends on <code>bstr</code> as a build-dependency with the &quot;default&quot; feature
We can further see that <code>bstr</code>'s  &quot;default&quot; feature enables &quot;unicode&quot; (among other features).</p>
<!--
[`cargo tree`]: ../../cargo/commands/cargo-tree.html
-->
<h1><a class="header" href="#intoiterator-for-arrays" id="intoiterator-for-arrays">IntoIterator for arrays</a></h1>
<h2><a class="header" href="#summary-7" id="summary-7">Summary</a></h2>
<ul>
<li>Arrays implement <code>IntoIterator</code> in <em>all</em> editions.</li>
<li>Calls to <code>IntoIterator::into_iter</code> are <em>hidden</em> in Rust 2015 and Rust 2018 when using method call syntax
(i.e., <code>array.into_iter()</code>). So, <code>array.into_iter()</code> still resolves to <code>(&amp;array).into_iter()</code> as it
has before.</li>
<li><code>array.into_iter()</code> changes meaning to be the call to <code>IntoIterator::into_iter</code> in Rust 2021.</li>
</ul>
<h2><a class="header" href="#details-4" id="details-4">Details</a></h2>
<p>Until Rust 1.53, only <em>references</em> to arrays implement <code>IntoIterator</code>.
This means you can iterate over <code>&amp;[1, 2, 3]</code> and <code>&amp;mut [1, 2, 3]</code>,
but not over <code>[1, 2, 3]</code> directly.</p>
<pre><code class="language-rust ignore">for &amp;e in &amp;[1, 2, 3] {} // Ok :)

for e in [1, 2, 3] {} // Error :(
</code></pre>
<p>This has been <a href="https://github.com/rust-lang/rust/issues/25725">a long-standing issue</a>, but the solution is not as simple as it seems.
Just <a href="https://github.com/rust-lang/rust/pull/65819">adding the trait implementation</a> would break existing code.
<code>array.into_iter()</code> already compiles today because that implicitly calls
<code>(&amp;array).into_iter()</code> due to <a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator">how method call syntax works</a>.
Adding the trait implementation would change the meaning.</p>
<p>Usually this type of breakage (adding a trait implementation) is categorized as 'minor' and acceptable.
But in this case there is too much code that would be broken by it.</p>
<p>It has been suggested many times to &quot;only implement <code>IntoIterator</code> for arrays in Rust 2021&quot;.
However, this is simply not possible.
You can't have a trait implementation exist in one edition and not in another,
since editions can be mixed.</p>
<p>Instead, the trait implementation was added in <em>all</em> editions (starting in Rust 1.53.0)
but with a small hack to avoid breakage until Rust 2021.
In Rust 2015 and 2018 code, the compiler will still resolve <code>array.into_iter()</code>
to <code>(&amp;array).into_iter()</code> like before, as if the trait implementation does not exist.
This <em>only</em> applies to the <code>.into_iter()</code> method call syntax.
It does not affect any other syntax such as <code>for e in [1, 2, 3]</code>, <code>iter.zip([1, 2, 3])</code> or
<code>IntoIterator::into_iter([1, 2, 3])</code>.
Those will start to work in <em>all</em> editions.</p>
<p>While it's a shame that this required a small hack to avoid breakage,
this solution keeps the difference between the editions to an absolute minimum.</p>
<h2><a class="header" href="#migration-2" id="migration-2">Migration</a></h2>
<p>A lint, <code>array_into_iter</code>, gets triggered whenever there is some call to <code>into_iter()</code> that will change
meaning in Rust 2021. The <code>array_into_iter</code> lint has already been a warning by default on all editions 
since the 1.41 release (with several enhancements made in 1.55). If your code is already warning free, 
then it should already be ready to go for Rust 2021!</p>
<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Because the difference between editions is small, the migration to Rust 2021 is fairly straight-forward.</p>
<p>For method calls of <code>into_iter</code> on arrays, the elements being implemented will change from references to owned values.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let array = [1u8, 2, 3];
  for x in array.into_iter() {
    // x is a `&amp;u8` in Rust 2015 and Rust 2018
    // x is a `u8` in Rust 2021
  }
}
</code></pre></pre>
<p>The most straightforward way to migrate in Rust 2021, is by keeping the exact behavior from previous editions
by calling <code>iter()</code> which also iterates over owned arrays by reference:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let array = [1u8, 2, 3];
  for x in array.iter() { // &lt;- This line changed
    // x is a `&amp;u8` in all editions
  }
}
</code></pre></pre>
<h3><a class="header" href="#optional-migration" id="optional-migration">Optional migration</a></h3>
<p>If you are using fully qualified method syntax (i.e., <code>IntoIterator::into_iter(array)</code>) in a previous edition,
this can be upgraded to method call syntax (i.e., <code>array.into_iter()</code>).</p>
<h1><a class="header" href="#disjoint-capture-in-closures" id="disjoint-capture-in-closures">Disjoint capture in closures</a></h1>
<h2><a class="header" href="#summary-8" id="summary-8">Summary</a></h2>
<ul>
<li><code>|| a.x + 1</code> now captures only <code>a.x</code> instead of <code>a</code>.</li>
<li>This can cause things to be dropped at different times or affect whether closures implement traits like <code>Send</code> or <code>Clone</code>.
<ul>
<li>If possible changes are detected, <code>cargo fix</code> will insert statements like <code>let _ = &amp;a</code> to force a closure to capture the entire variable.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#details-5" id="details-5">Details</a></h2>
<p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closures</a>
automatically capture anything that you refer to from within their body.
For example, <code>|| a + 1</code> automatically captures a reference to <code>a</code> from the surrounding context.</p>
<p>In Rust 2018 and before, closures capture entire variables, even if the closure only uses one field.
For example, <code>|| a.x + 1</code> captures a reference to <code>a</code> and not just <code>a.x</code>.
Capturing <code>a</code> in its entirety prevents mutation or moves from other fields of <code>a</code>, so that code like this does not compile:</p>
<pre><code class="language-rust ignore">let a = SomeStruct::new();
drop(a.x); // Move out of one field of the struct
println!(&quot;{}&quot;, a.y); // Ok: Still use another field of the struct
let c = || println!(&quot;{}&quot;, a.y); // Error: Tries to capture all of `a`
c();
</code></pre>
<p>Starting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.</p>
<p>Disjoint capture was proposed as part of <a href="https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md">RFC 2229</a> and the RFC contains details about the motivation.</p>
<h2><a class="header" href="#migration-3" id="migration-3">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <code>rust_2021_incompatible_closure_captures</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to have <code>rustfix</code> migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Below is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail 
or you would like to better understand how the migration works.</p>
<p>Changing the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:</p>
<ul>
<li>changes to drop order, or when destructors run (<a href="rust-2021/disjoint-capture-in-closures.html#drop-order">details</a>);</li>
<li>changes to which traits a closure implements (<a href="rust-2021/disjoint-capture-in-closures.html#trait-implementations">details</a>).</li>
</ul>
<p>Whenever any of the scenarios below are detected, <code>cargo fix</code> will insert a &quot;dummy let&quot; into your closure to force it to capture the entire variable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (vec![22], vec![23]);
let c = move || {
    // &quot;Dummy let&quot; that forces `x` to be captured in its entirety
    let _ = &amp;x;

    // Otherwise, only `x.0` would be captured here
    println!(&quot;{:?}&quot;, x.0);
};
<span class="boring">}
</span></code></pre></pre>
<p>This is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.</p>
<h3><a class="header" href="#wild-card-patterns" id="wild-card-patterns">Wild Card Patterns</a></h3>
<p>Closures now only capture data that needs to be read, which means the following closures will not capture <code>x</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let c = || {
    let _ = x; // no-op
};

let c = || match x {
    _ =&gt; println!(&quot;Hello World!&quot;)
};
<span class="boring">}
</span></code></pre></pre>
<p>The <code>let _ = x</code> statement here is a no-op, since the <code>_</code> pattern completely ignores the right-hand side, and <code>x</code> is a reference to a place in memory (in this case, a variable).</p>
<p>This change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the &quot;drop order&quot; change below.</p>
<p><strong>Subtle:</strong> There are other similar expressions, such as the &quot;dummy lets&quot; <code>let _ = &amp;x</code> that we insert, which are not no-ops. This is because the right-hand side (<code>&amp;x</code>) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).</p>
<h3><a class="header" href="#drop-order" id="drop-order">Drop Order</a></h3>
<p>When a closure takes ownership of a value from a variable <code>t</code>, that value is then dropped when the closure is dropped, and not when the variable <code>t</code> goes out of scope:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>{
    let t = (vec![0], vec![0]);

    {
        let c = || move_value(t); // t is moved here
    } // c is dropped, which drops the tuple `t` as well
} // t goes out of scope here
<span class="boring">}
</span></code></pre></pre>
<p>The above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of <em>part</em> of a variable, there can be differences:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>{
    let t = (vec![0], vec![0]);

    {
        let c = || {
            // In Rust 2018, captures all of `t`.
            // In Rust 2021, captures only `t.0`
            move_value(t.0);
        };

        // In Rust 2018, `c` (and `t`) are both dropped when we
        // exit this block.
        //
        // In Rust 2021, `c` and `t.0` are both dropped when we
        // exit this block.
    }

// In Rust 2018, the value from `t` has been moved and is
// not dropped.
//
// In Rust 2021, the value from `t.0` has been moved, but `t.1`
// remains, so it will be dropped here.
}
<span class="boring">}
</span></code></pre></pre>
<p>In most cases, dropping values at different times just affects when memory is freed and is not important. However, some <code>Drop</code> impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy <code>let</code> to force the entire variable to be captured.</p>
<h3><a class="header" href="#trait-implementations" id="trait-implementations">Trait implementations</a></h3>
<p>Closures automatically implement the following traits based on what values they capture:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>: if all captured values are <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits">Auto traits</a> like <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, and <a href="https://doc.rust-lang.org/std/marker/trait.UnwindSafe.html"><code>UnwindSafe</code></a>: if all captured values implement the given trait.</li>
</ul>
<p>In Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then &quot;dummy lets&quot; are inserted.</p>
<p>For instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement <code>Send</code>/<code>Sync</code> auto trait for the wrapper. The closure that is passed to <code>thread::spawn</code> uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is <code>Send</code>/<code>Sync</code>, the code is considered safe and therefore compiles successfully.</p>
<p>With disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally <code>Send</code>/<code>Sync</code> defeating the purpose of the wrapper.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

struct Ptr(*mut i32);
unsafe impl Send for Ptr {}


let mut x = 5;
let px = Ptr(&amp;mut x as *mut i32);

let c = thread::spawn(move || {
    unsafe {
        *(px.0) += 10;
    }
}); // Closure captured px.0 which is not Send
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#panic-macro-consistency" id="panic-macro-consistency">Panic macro consistency</a></h1>
<h2><a class="header" href="#summary-9" id="summary-9">Summary</a></h2>
<ul>
<li><code>panic!(..)</code> now always uses <code>format_args!(..)</code>, just like <code>println!()</code>.</li>
<li><code>panic!(&quot;{&quot;)</code> is no longer accepted, without escaping the <code>{</code> as <code>{{</code>.</li>
<li><code>panic!(x)</code> is no longer accepted if <code>x</code> is not a string literal.
<ul>
<li>Use <code>std::panic::panic_any(x)</code> to panic with a non-string payload.</li>
<li>Or use <code>panic!(&quot;{}&quot;, x)</code> to use <code>x</code>'s <code>Display</code> implementation.</li>
</ul>
</li>
<li>The same applies to <code>assert!(expr, ..)</code>.</li>
</ul>
<h2><a class="header" href="#details-6" id="details-6">Details</a></h2>
<p>The <code>panic!()</code> macro is one of Rust's most well known macros.
However, it has <a href="https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md">some subtle surprises</a>
that we can't just change due to backwards compatibility.</p>
<pre><code class="language-rust ignore">// Rust 2018
panic!(&quot;{}&quot;, 1); // Ok, panics with the message &quot;1&quot;
panic!(&quot;{}&quot;); // Ok, panics with the message &quot;{}&quot;
</code></pre>
<p>The <code>panic!()</code> macro only uses string formatting when it's invoked with more than one argument.
When invoked with a single argument, it doesn't even look at that argument.</p>
<pre><code class="language-rust ignore">// Rust 2018
let a = &quot;{&quot;;
println!(a); // Error: First argument must be a format string literal
panic!(a); // Ok: The panic macro doesn't care
</code></pre>
<p>It even accepts non-strings such as <code>panic!(123)</code>, which is uncommon and rarely useful since it
produces a surprisingly unhelpful message: <code>panicked at 'Box&lt;Any&gt;'</code>.</p>
<p>This will especially be a problem once
<a href="https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html">implicit format arguments</a>
are stabilized.
That feature will make <code>println!(&quot;hello {name}&quot;)</code> a short-hand for <code>println!(&quot;hello {}&quot;, name)</code>.
However, <code>panic!(&quot;hello {name}&quot;)</code> would not work as expected,
since <code>panic!()</code> doesn't process a single argument as format string.</p>
<p>To avoid that confusing situation, Rust 2021 features a more consistent <code>panic!()</code> macro.
The new <code>panic!()</code> macro will no longer accept arbitrary expressions as the only argument.
It will, just like <code>println!()</code>, always process the first argument as format string.
Since <code>panic!()</code> will no longer accept arbitrary payloads,
<a href="https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html"><code>panic_any()</code></a>
will be the only way to panic with something other than a formatted string.</p>
<pre><code class="language-rust ignore">// Rust 2021
panic!(&quot;{}&quot;, 1); // Ok, panics with the message &quot;1&quot;
panic!(&quot;{}&quot;); // Error, missing argument
panic!(a); // Error, must be a string literal
</code></pre>
<p>In addition, <code>core::panic!()</code> and <code>std::panic!()</code> will be identical in Rust 2021.
Currently, there are some historical differences between those two,
which can be noticeable when switching <code>#![no_std]</code> on or off.</p>
<h2><a class="header" href="#migration-4" id="migration-4">Migration</a></h2>
<p>A lint, <code>non_fmt_panics</code>, gets triggered whenever there is some call to <code>panic</code> that uses some 
deprecated behavior that will error in Rust 2021. The <code>non_fmt_panics</code> lint has already been a warning 
by default on all editions since the 1.50 release (with several enhancements made in later releases). 
If your code is already warning free, then it should already be ready to go for Rust 2021!</p>
<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Should you choose or need to manually migrate, you'll need to update all panic invocations to either use the same 
formatting as <code>println</code> or use <code>std::panic::panic_any</code> to panic with non-string data.</p>
<p>For example, in the case of <code>panic!(MyStruct)</code>, you'll need to convert to using <code>std::panic::panic_any</code> (note
that this is a function not a macro): <code>std::panic::panic_any(MyStruct)</code>.</p>
<p>In the case of panic messages that include curly braces but the wrong number of arguments (e.g., <code>panic!(&quot;Some curlies: {}&quot;)</code>), 
you can panic with the string literal by either using the same syntax as <code>println!</code> (i.e., <code>panic!(&quot;{}&quot;, &quot;Some curlies: {}&quot;)</code>) 
or by escaping the curly braces (i.e., <code>panic!(&quot;Some curlies: {{}}&quot;)</code>).</p>
<h1><a class="header" href="#reserving-syntax" id="reserving-syntax">Reserving syntax</a></h1>
<h2><a class="header" href="#summary-10" id="summary-10">Summary</a></h2>
<ul>
<li><code>any_identifier#</code>, <code>any_identifier&quot;...&quot;</code>, and <code>any_identifier'...'</code> are now reserved
syntax, and no longer tokenize.</li>
<li>This is mostly relevant to macros. E.g. <code>quote!{ #a#b }</code> is no longer accepted.</li>
<li>It doesn't treat keywords specially, so e.g. <code>match&quot;...&quot; {}</code> is no longer accepted.</li>
<li>Insert whitespace between the identifier and the subsequent <code>#</code>, <code>&quot;</code>, or <code>'</code>
to avoid errors.</li>
<li>Edition migrations will help you insert whitespace in such cases.</li>
</ul>
<h2><a class="header" href="#details-7" id="details-7">Details</a></h2>
<p>To make space for new syntax in the future,
we've decided to reserve syntax for prefixed identifiers and literals:
<code>prefix#identifier</code>, <code>prefix&quot;string&quot;</code>, <code>prefix'c'</code>, and <code>prefix#123</code>,
where <code>prefix</code> can be any identifier.
(Except those prefixes that already have a meaning, such as <code>b'...'</code> (byte
strings) and <code>r&quot;...&quot;</code> (raw strings).)</p>
<p>This provides syntax we can expand into in the future without requiring an
edition boundary. We may use this for temporary syntax until the next edition,
or for permanent syntax if appropriate.</p>
<p>Without an edition, this would be a breaking change, since macros can currently
accept syntax such as <code>hello&quot;world&quot;</code>, which they will see as two separate
tokens: <code>hello</code> and <code>&quot;world&quot;</code>. The (automatic) fix is simple though: just
insert a space: <code>hello &quot;world&quot;</code>. Likewise, <code>prefix#ident</code> should become
<code>prefix #ident</code>. Edition migrations will help with this fix.</p>
<p>Other than turning these into a tokenization error,
<a href="https://github.com/rust-lang/rfcs/pull/3101">the RFC</a> does not attach a meaning to any prefix yet.
Assigning meaning to specific prefixes is left to future proposals,
which will now—thanks to reserving these prefixes—not be breaking changes.</p>
<p>Some new prefixes you might potentially see in the future (though we haven't
committed to any of them yet):</p>
<ul>
<li>
<p><code>k#keyword</code> to allow writing keywords that don't exist yet in the current edition.
For example, while <code>async</code> is not a keyword in edition 2015,
this prefix would've allowed us to accept <code>k#async</code> in edition 2015
without having to wait for edition 2018 to reserve <code>async</code> as a keyword.</p>
</li>
<li>
<p><code>f&quot;&quot;</code> as a short-hand for a format string.
For example, <code>f&quot;hello {name}&quot;</code> as a short-hand for the equivalent <code>format!()</code> invocation.</p>
</li>
<li>
<p><code>s&quot;&quot;</code> for <code>String</code> literals.</p>
</li>
<li>
<p><code>c&quot;&quot;</code> or <code>z&quot;&quot;</code> for null-terminated C strings.</p>
</li>
</ul>
<h2><a class="header" href="#migration-5" id="migration-5">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <code>rust_2021_prefixes_incompatible_syntax</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to have <code>rustfix</code> migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Should you want or need to manually migrate your code, migration is fairly straight-forward.</p>
<p>Let's say you have a macro that is defined like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro {
    ($a:tt $b:tt) =&gt; {};
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the first token tree and the second:</p>
<pre><code class="language-rust ignore">my_macro!(z&quot;hey&quot;);
</code></pre>
<p>This <code>z</code> prefix is no longer allowed in Rust 2021, so in order to call this macro, you must add a space after the prefix like so:</p>
<pre><code class="language-rust ignore">my_macro!(z &quot;hey&quot;);
</code></pre>
<h1><a class="header" href="#warnings-promoted-to-errors" id="warnings-promoted-to-errors">Warnings promoted to errors</a></h1>
<h2><a class="header" href="#summary-11" id="summary-11">Summary</a></h2>
<ul>
<li>Code that triggered the <code>bare_trait_objects</code> and <code>ellipsis_inclusive_range_patterns</code> lints will error in Rust 2021.</li>
</ul>
<h2><a class="header" href="#details-8" id="details-8">Details</a></h2>
<p>Two existing lints are becoming hard errors in Rust 2021, but these lints will remain warnings in older editions.</p>
<h3><a class="header" href="#bare_trait_objects" id="bare_trait_objects"><code>bare_trait_objects</code>:</a></h3>
<p>The use of the <code>dyn</code> keyword to identify <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait objects</a>
will be mandatory in Rust 2021.</p>
<p>For example, the following code which does not include the <code>dyn</code> keyword in <code>&amp;MyTrait</code>
will produce an error instead of just a lint in Rust 2021:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {}

pub fn my_function(_trait_object: &amp;MyTrait) { // should be `&amp;dyn MyTrait`
  unimplemented!()
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#ellipsis_inclusive_range_patterns" id="ellipsis_inclusive_range_patterns"><code>ellipsis_inclusive_range_patterns</code>:</a></h3>
<p>The <a href="https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns">deprecated <code>...</code> syntax</a>
for inclusive range patterns (i.e., ranges where the end value is <em>included</em> in the range) is no longer 
accepted in Rust 2021. It has been superseded by <code>..=</code>, which is consistent with expressions.</p>
<p>For example, the following code which uses <code>...</code> in a pattern will produce an error instead of 
just a lint in Rust 2021:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn less_or_eq_to_100(n: u8) -&gt; bool {
  matches!(n, 0...100) // should be `0..=100`
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#migrations" id="migrations">Migrations</a></h2>
<p>If your Rust 2015 or 2018 code does not produce any warnings for <code>bare_trait_objects</code> 
or <code>ellipsis_inclusive_range_patterns</code> and you've not allowed these lints through the 
use of <code>#![allow()]</code> or some other mechanism, then there's no need to migrate.</p>
<p>To automatically migrate any crate that uses <code>...</code> in patterns or does not use <code>dyn</code> with
trait objects, you can run <code>cargo fix --edition</code>.</p>
<h1><a class="header" href="#or-patterns-in-macro-rules" id="or-patterns-in-macro-rules">Or patterns in macro-rules</a></h1>
<h2><a class="header" href="#summary-12" id="summary-12">Summary</a></h2>
<ul>
<li>How patterns work in <code>macro_rules</code> macros changes slightly:
<ul>
<li><code>$_:pat</code> in <code>macro_rules</code> now matches usage of <code>|</code> too: e.g. <code>A | B</code>.</li>
<li>The new <code>$_:pat_param</code> behaves like <code>$_:pat</code> did before; it does not match (top level) <code>|</code>.</li>
<li><code>$_:pat_param</code> is available in all editions.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#details-9" id="details-9">Details</a></h2>
<p>Starting in Rust 1.53.0, <a href="https://doc.rust-lang.org/stable/reference/patterns.html">patterns</a>
are extended to support <code>|</code> nested anywhere in the pattern.
This enables you to write <code>Some(1 | 2)</code> instead of <code>Some(1) | Some(2)</code>.
Since this was simply not allowed before, this is not a breaking change.</p>
<p>However, this change also affects <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html"><code>macro_rules</code> macros</a>.
Such macros can accept patterns using the <code>:pat</code> fragment specifier.
Currently, <code>:pat</code> does <em>not</em> match top level <code>|</code>, since before Rust 1.53,
not all patterns (at all nested levels) could contain a <code>|</code>.
Macros that accept patterns like <code>A | B</code>,
such as <a href="https://doc.rust-lang.org/1.51.0/std/macro.matches.html"><code>matches!()</code></a>
use something like <code>$($_:pat)|+</code>. </p>
<p>Because this would potentially break existing macros, the meaning of <code>:pat</code> did 
not change in Rust 1.53.0 to include <code>|</code>. Instead, that change happens in Rust 2021. 
In the new edition, the <code>:pat</code> fragment specifier <em>will</em> match <code>A | B</code>.</p>
<p><code>$_:pat</code> fragments in Rust 2021 cannot be followed by an explicit <code>|</code>. Since there are times 
that one still wishes to match pattern fragments followed by a <code>|</code>, the fragment specified <code>:pat_param</code> 
has been added to retain the older behavior.</p>
<p>It's important to remember that editions are <em>per crate</em>, so the only relevant edition is the edition
of the crate where the macro is defined. The edition of the crate where the macro is used does not 
change how the macro works.</p>
<h2><a class="header" href="#migration-6" id="migration-6">Migration</a></h2>
<p>A lint, <code>rust_2021_incompatible_or_patterns</code>, gets triggered whenever there is a use <code>$_:pat</code> which
will change meaning in Rust 2021. </p>
<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>If you have a macro which relies on <code>$_:pat</code> not matching the top level use of <code>|</code> in patterns, 
you'll need to change each occurrence of <code>$_:pat</code> to <code>$_:pat_param</code>.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro { 
	($x:pat | $y:pat) =&gt; {
		// TODO: implementation
	} 
}

// This macro works in Rust 2018 since `$x:pat` does not match against `|`:
my_macro!(1 | 2);

// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not allowed
// to be followed by a `|`. To make sure this macro still works in Rust 2021
// change the macro to the following:
macro_rules! my_macro { 
	($x:pat_param | $y:pat) =&gt; { // &lt;- this line is different
		// TODO: implementation
	} 
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
